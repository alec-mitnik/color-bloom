<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="description" content="Make images/wallpapers with this unique web app that utilizes special color bloom effects." />
<meta name="theme-color" content="#313437" />

<link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon.png">
<!-- Better to just use the ico file, since with PNGs, PC browsers use the 32x32 one despite rendering at 16x16 -->
<!-- <link rel="icon" type="image/png" sizes="32x32" href="/images/icons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/images/icons/favicon-16x16.png"> -->
<link rel="manifest" href="/site.webmanifest">

<link rel="stylesheet" type="text/css" href="./styles.css">

<title>Color Bloom Art Maker</title>

<script>
"use strict"

/* TODO:
 * - Reveal options more gradually and/or show a guided tour
 * - Persist whole history?
 * - Support stored fill settings history/presets?
 * - Support rotating the canvas (based on orientation or manual)
 * - Move into own folder and split out scripts
 * - Support share/download quality selection, at least full quality vs. default
 * - Better shortcut handling (prevent duplicates, display and store robustly, warn about reserved combos...)
 * - Generate spiral pattern
 * - More template images
 * - Support uploading own images as templates, or maybe as translucent overlays to trace?
 * - Support color selection for brush?
 * - Support moving canvas contents around?
 * - Support custom canvas sizes?
 * - Support width varying by speed of strokes or pressure of touch/stylus?
 * - Consider using pointer events instead of separate mouse and touch events?  Not worth it except for getting pressure values.
 */

let CANVAS_WIDTH = 1920;
let CANVAS_HEIGHT = 1200;
const DELAY_THRESHOLD = 1000;
let STARTING_SATURATION = 1;
let SATURATION_MUTATION = 0;

// Only applies if using HSL
const MIN_LIGHTNESS = 0.0;
const MAX_LIGHTNESS = 0.6;

let LIGHTNESS_MUTATION;
let STARTING_LIGHTNESS;
let HUE_MUTATION;

const HISTORY_LIMIT = 1 + 10;
const BRUSH_STROKE_REPEATS = 50;
let brushStrokeCounter = 1;
let combinedHistory = [];
let combinedHistoryIndex = 0;
let fillImageDataHistory = [];
let fillPixelGridHistory = [];
let brushPixelGridHistory = [];
let fillCanvasHistory = [];
let brushCanvasHistory = [];
let fillHistoryIndex = 0;
let brushHistoryIndex = 0;
let blooms = new Map();
let growthActive = false;
let erasingOutlineForMousePress;
let interactive = true;
let isDrawing = false;
let isFilling = false;
let allBrushstrokePoints = [];
let previousBrushstrokePoints = [];
let brushPixelsChanged = false;
let fillPixelsChanged = false;
let canvasMoveScheduled = false;
let storedMovementX = 0;
let storedMovementY = 0;
let storedScaleValue = NaN;
let clickTimeoutId;
const touches = new Map();
let startingTouchDistance = NaN;
let startingScaleValue = NaN;
let canvasDB;

const defaultShortcuts = {
  view_canvas: {
    displayName: 'View Canvas',
    commands: [
      {
        key: 'v',
        code: 'KeyV',
        alt: true,
      },
    ],
  },
  brush: {
    displayName: 'Select Brush',
    commands: [
      {
        key: '1',
        code: 'Digit1',
        alt: true,
      },
    ],
  },
  fill: {
    displayName: 'Select Fill',
    commands: [
      {
        key: '2',
        code: 'Digit2',
        alt: true,
      },
    ],
  },
  erase: {
    displayName: 'Select Erase',
    commands: [
      {
        key: '3',
        code: 'Digit3',
        alt: true,
      },
    ],
  },
  fill_color: {
    displayName: 'Select Color for Fill',
    commands: [
      {
        key: 'c',
        code: 'KeyC',
        alt: true,
      },
    ],
  },
  show_guidelines: {
    displayName: 'Toggle Guidelines',
    commands: [
      {
        key: 'l',
        code: 'KeyL',
        alt: true,
      },
    ],
  },
  reset_scale: {
    displayName: 'Reset Scale and Position',
    commands: [
      {
        key: '0',
        code: 'Numpad0',
        alt: true,
      },
    ],
  },
  reset_canvas: {
    displayName: 'Reset Canvas',
    commands: [
      {
        key: 'r',
        code: 'KeyR',
        alt: true,
      },
    ],
  },
  undo: {
    displayName: 'Undo',
    commands: [
      {
        key: 'z',
        code: 'KeyZ',
        ctrl: true,
      },
    ],
  },
  redo: {
    displayName: 'Redo',
    commands: [
      {
        key: 'y',
        code: 'KeyY',
        ctrl: true,
      },
      {
        key: 'Z',
        code: 'KeyZ',
        ctrl: true,
        shift: true,
      },
    ],
  },
  toggle_toolbar_collapse: {
    displayName: 'Toggle Toolbar Collapse',
    commands: [
      {
        key: 't',
        code: 'KeyT',
        alt: true,
      },
    ],
  },
};

let shortcuts = structuredClone(defaultShortcuts);

window.addEventListener('DOMContentLoaded', init);
window.addEventListener('pageshow', loadAllData);

window.addEventListener('resize', () => {
  setRelativeCanvasOffsetsWithLimits(0, 0);
});

window.screen.orientation.addEventListener('change', () => {
  setRelativeCanvasOffsetsWithLimits(0, 0);
});

window.addEventListener('keydown', (event) => {
  if (document.querySelector('dialog[open]')) {
    return;
  }

  if (document.getElementById('toolbar').classList.contains('hidden')) {
    event.preventDefault();
    event.stopPropagation();
    stopViewingCanvas();
    return;
  }

  for (const property in shortcuts) {
    for (const shortcut of shortcuts[property].commands) {
      const lastChar = event.code.charAt(event.code.length - 1);
      const isNumeric = !isNaN(parseInt(lastChar));

      if ((event.key.toUpperCase() === shortcut.key.toUpperCase()
          || event.code === shortcut.code
          || (isNumeric && shortcut.code.endsWith(lastChar)))
          && event.ctrlKey === !!shortcut.ctrl
          && event.shiftKey === !!shortcut.shift
          && event.altKey === !!shortcut.alt
          && event.metaKey === !!shortcut.meta) {
        event.preventDefault();
        event.stopPropagation();

        switch (property) {
          case 'view_canvas':
            viewCanvas();
            break;
          case 'brush':
            document.querySelector('input[name=tool][value=brush]').checked = true;
            announceForScreenReader("Brush selected.");
            break;
          case 'fill':
            document.querySelector('input[name=tool][value=fill]').checked = true;
            announceForScreenReader("Fill selected.");
            break;
          case 'erase':
            document.querySelector('input[name=tool][value=erase]').checked = true;
            announceForScreenReader("Erase selected.");
            break;
          case 'fill_color':
            document.querySelector('input[name=tool][value=fill]').checked = true;
            setTimeout(() => document.querySelector('input[name=fillColor]').click());
            break;
          case 'show_guidelines': {
            const guidelinesCheckbox = document.querySelector('input[name=show-guidelines]');
            guidelinesCheckbox.checked = !guidelinesCheckbox.checked;
            break;
          }
          case 'reset_scale':
            resetScaleAndPosition();
            break;
          case 'reset_canvas':
            resetCanvas();
            break;
          case 'undo':
            undo();
            break;
          case 'redo':
            redo();
            break;
          case 'toggle_toolbar_collapse': {
            const toggleCollapseCheckbox = document.querySelector('input[name=toggle-collapse]');
            toggleCollapseCheckbox.checked = !toggleCollapseCheckbox.checked;
            announceForScreenReader(toggleCollapseCheckbox.checked ? "Toolbar collapsed." : "Toolbar expanded.");
            break;
          }
          default:
            // Do nothing

          return;
        }
      }
    }
  }
});

function generateStartingHue() {
  return Math.random() * 360;
}

function getStartingColor() {
  return rgb2hsl(...hex2rgb(getToolbarData().fillColor));
}

let STARTING_HUE = generateStartingHue();

function hex2rgb(hex) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return [r, g, b];
}

function rgb2hsl(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;

  // Find min and max values
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);

  let h, s, l = (max + min) / 2;

  if (max === min) {
    // Achromatic
    h = s = 0;
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }

  return {
    h: Math.round(h * 360),
    s,
    l,
  };
}

function hsl2rgb(h, s, l) {
  h = h / 360;

  let r, g, b;

  if (s === 0) {
    // Achromatic, set to the lightness value (this is l, not 1)
    r = g = b = l;
  } else {
    // Helper function to convert hue to RGB
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };

    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;

    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255)
  };
}

function blendHslWithAlpha(baseColor, overlayColor) {
  // Convert HSL to RGB for both colors
  const baseRGB = hsl2rgb(baseColor.h, baseColor.s, baseColor.l);
  const overlayRGB = hsl2rgb(overlayColor.h, overlayColor.s, overlayColor.l);

  const blendChannel = (base, overlay, alpha) => {
    return Math.round(base * (1 - alpha) + overlay * alpha);
  };

  // Apply alpha blending in RGB space
  const resultRGB = {
    r: blendChannel(baseRGB.r, overlayRGB.r, overlayColor.a),
    g: blendChannel(baseRGB.g, overlayRGB.g, overlayColor.a),
    b: blendChannel(baseRGB.b, overlayRGB.b, overlayColor.a)
  };

  // Convert the result back to HSL
  return rgb2hsl(resultRGB.r, resultRGB.g, resultRGB.b);
}

function randIndex(arr, forSplice = false) {
  return Math.floor(Math.random() * (arr.length + (forSplice ? 1 : 0)));
}

function randEl(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

/* function removeEl(arr, el) {
  return arr.splice(arr.indexOf(el), 1)[0];
}

function pluckRandEl(arr) {
  return removeEl(arr, randEl(arr));
} */

function getToolbarData() {
  const form = document.getElementById("toolbar");
  const data = new FormData(form);
  return Object.fromEntries(data);
}

function step() {
  return new Promise(resolve => {
    // requestAnimationFrame(resolve);
    setTimeout(resolve);
  });
}

function getColorString(h, s, l, a = 1) {
  const colorString = `hsla(${h}, ${Math.round(s * 100)}%, ${Math.round(l * 100)}%, ${a})`;
  return colorString;
}

/* function drawPixel(pixel, canvas) {
  const context = canvas.getContext("2d");
  context.shadowBlur = 0;
  context.fillStyle = getColorString(pixel.h, pixel.s, pixel.l, pixel?.a ?? 1);
  context.fillRect(pixel.x, pixel.y, 1, 1);
} */

function addFillPixel(x, y, h, s, l, startingPixel = undefined) {
  const fillPixelGrid = getFillPixelGrid();
  const existingPixel = fillPixelGrid[x][y];
  let pixelToDraw = {x, y, h, s, l};

  if (existingPixel) {
    pixelToDraw = {...pixelToDraw, ...blendHslWithAlpha(pixelToDraw, existingPixel)};
  }

  // The pixel grid data needs to reflect the original color so that branches stemming from it won't be diluted.
  // Allow brushstroke to be distinguished for erase TODO - unnecessary now?
  const pixel = {x, y, h, s, l: Math.max(l, 0.01), a: 1};
  fillPixelGrid[x][y] = pixel;
  fillPixelsChanged = true;
  // drawPixel(pixelToDraw, getFillCanvas());

  const fillImageData = getFillImageData();
  assignImageDataPixel(fillImageData, pixelToDraw);

  if (!countsAsOutlineAt(x, y)) {
    if (blooms.has(startingPixel)) {
      const branches = blooms.get(startingPixel);
      branches.splice(randIndex(branches, true), 0, pixel);
      blooms.set(startingPixel, branches);
    } else {
      blooms.set(pixel, [pixel]);
    }
  }
}

function erasePixel(x, y, erasingOutline, startingPixel = undefined) {
  const fillPixelGrid = getFillPixelGrid();
  // const fillCanvas = getFillCanvas();
  // const fillCanvasContext = fillCanvas.getContext("2d");

  if (erasingOutline) {
    const brushPixelGrid = getBrushPixelGrid();
    const a = brushPixelGrid[x][y]?.a ?? 1;
    brushPixelGrid[x][y] = undefined;
    brushPixelsChanged = true;

    const brushCanvas = getBrushCanvas();
    const brushCanvasContext = brushCanvas.getContext("2d");
    brushCanvasContext.clearRect(x, y, 1, 1);

    const fillPixel = fillPixelGrid[x][y];

    if (fillPixel) {
      // fillCanvasContext.clearRect(x, y, 1, 1);

      // if (a === 1) {
      //   fillPixelGrid[x][y] = undefined;
      // } else {
        fillPixel.a *= (1 - a);
        fillPixelGrid[x][y] = fillPixel;
        // drawPixel(fillPixel, fillCanvas);
      // }

      const fillImageData = getFillImageData();
      assignImageDataPixel(fillImageData, fillPixel);

      fillPixelsChanged = true;
    }
  } else {
    fillPixelGrid[x][y] = undefined;
    // fillCanvasContext.clearRect(x, y, 1, 1);
    const fillImageData = getFillImageData();
    assignImageDataPixel(fillImageData, {x, y, h: 0, s: 0, l: 0, a: 0});
    fillPixelsChanged = true;
  }

  if (erasingOutline || !countsAsOutlineAt(x, y)) {
    const pixel = {x, y};

    if (blooms.has(startingPixel)) {
      const branches = blooms.get(startingPixel);
      branches.splice(randIndex(branches, true), 0, pixel);
      blooms.set(startingPixel, branches);
    } else {
      blooms.set(pixel, [pixel]);
    }
  }
}

function addBrushstroke(x, y) {
  const brushSize = getToolbarData().brushSize - 2;
  const canvas = getBrushCanvas();

  const context = canvas.getContext("2d");
  context.strokeStyle = "black";
  context.lineWidth = brushSize - 2;
  context.lineCap = "round";
  context.lineJoin = "round";
  context.shadowColor = context.strokeStyle;
  context.shadowBlur = 2;

  if (previousBrushstrokePoints.length) {
    context.beginPath();
    context.moveTo(previousBrushstrokePoints[previousBrushstrokePoints.length - 1].x,
        previousBrushstrokePoints[previousBrushstrokePoints.length - 1].y);

    for (let i = previousBrushstrokePoints.length - 2; i >= 0; i--) {
      context.lineTo(previousBrushstrokePoints[i].x, previousBrushstrokePoints[i].y);
    }

    context.stroke();
  } else {
    context.beginPath();
    context.moveTo(x, y);

    // iOS Safari won't render a line with a single point, so add a tiny offset
    context.lineTo(x + 0.01, y);
    context.stroke();
  }

  previousBrushstrokePoints.unshift({x, y});

  if (previousBrushstrokePoints.length > BRUSH_STROKE_REPEATS) {
    previousBrushstrokePoints.pop();
  }

  const distance = (x - allBrushstrokePoints[allBrushstrokePoints.length - 1]?.x) ** 2
      + (y - allBrushstrokePoints[allBrushstrokePoints.length - 1]?.y) ** 2;

  if (allBrushstrokePoints.length === 0) {
    allBrushstrokePoints.push({x, y});
    brushStrokeCounter = 1;
  } else {
    if (distance > getSmoothingSquaredDistance() || brushStrokeCounter % Math.ceil(getSmoothingSquaredDistance() * 0.005 + 1) === 0) {
      brushStrokeCounter = 1;
      allBrushstrokePoints.push({x, y});
    } else {
      brushStrokeCounter++;
    }
  }
}

function getSmoothingSquaredDistance() {
  return getToolbarData().smoothing ** 3 * 50000;
}

function mutateHue(h) {
  let actualMutation = HUE_MUTATION * 7.5;

  if (h >= 23 && h <= 27) {
    // Not enough orange
    actualMutation *= 0.5;
  } else if (h >= 100 && h <= 120) {
    // Too much green
    actualMutation *= 2;
  } else if (h >= 192 && h <= 198) {
    // Not enough light blue
    actualMutation *= 0.5;
  } else if (h >= 265 && h <= 275) {
    // Not enough purple
    if (h >= 269 && h <= 271) {
      actualMutation *= 0.25;
    } else {
      actualMutation *= 0.5;
    }
  }

  return (Math.random() * actualMutation * 2 - actualMutation + h + 360) % 360;
}

function mutateSaturation(s) {
  const actualMutation = SATURATION_MUTATION * 0.05;
  return Math.max(Math.min((Math.random() * (actualMutation * 2)) - actualMutation + s, 1), 0);
}

function mutateLightness(l, s) {
  const actualMutation = LIGHTNESS_MUTATION * 0.05;
  const newValue = (Math.random() * (actualMutation * 2)) - actualMutation + l;

  // Use max lightness value when starting lightness is 0.5 and saturation is 1,
  // and let max lightness go to 1 as these values go to 0/1 and 0 respectively
  const effectiveMaxLightness = 1 - ((1 - MAX_LIGHTNESS) * s * (1 - (2 * Math.abs(0.5 - STARTING_LIGHTNESS))));
  return Math.max(Math.min(newValue, effectiveMaxLightness), MIN_LIGHTNESS);
}

function growBranch(erase = false, erasingOutline = false) {
  const [startingPixel, randBranch] = randEl([...blooms.entries()]);
  const randBranchPixel = randBranch.shift();
  const sizeLimit = parseInt(erase ? getToolbarData().eraseSize : getToolbarData().fillSize) / 2;

  const neighbors = [
    {x: randBranchPixel.x - 1, y: randBranchPixel.y},
    {x: randBranchPixel.x + 1, y: randBranchPixel.y},
    {x: randBranchPixel.x, y: randBranchPixel.y - 1},
    {x: randBranchPixel.x, y: randBranchPixel.y + 1},
  ];

  for (const neighbor of neighbors) {
    if (neighbor.x >= 0 && neighbor.x < CANVAS_WIDTH
        && neighbor.y >= 0 && neighbor.y < CANVAS_HEIGHT) {

      if (!isNaN(sizeLimit)
          && ((neighbor.x - startingPixel.x) ** 2 + (neighbor.y - startingPixel.y) ** 2) > sizeLimit ** 2) {
        // This gives perfect circles (with pixelated edges)
        // continue;

        // This gives more naturalistic splotches
        blooms.delete(startingPixel);
        return;
      }

      if (!erase) {
        if (!(getFillPixelGrid()[neighbor.x][neighbor.y]?.a === 1) && !countsAsOutlineAt(neighbor.x, neighbor.y)) {
          addFillPixel(
            neighbor.x,
            neighbor.y,
            mutateHue(randBranchPixel.h),
            mutateSaturation(randBranchPixel.s),
            mutateLightness(randBranchPixel.l, randBranchPixel.s),
            startingPixel,
          );
        }
      } else {
        if ((erasingOutline && getBrushPixelGrid()[neighbor.x][neighbor.y])
            || (!erasingOutline && getFillPixelGrid()[neighbor.x][neighbor.y])) {
          erasePixel(neighbor.x, neighbor.y, erasingOutline, startingPixel);
        }
      }
    }
  };

  if (!blooms.get(startingPixel).length) {
    blooms.delete(startingPixel);
  }
}

function countsAsOutlineAt(x, y) {
  const pixelGrid = getBrushPixelGrid();

  if (!pixelGrid[x]?.[y]) {
    return false;
  }

  if ((pixelGrid[x][y]?.a ?? 1) > 0.985) {
    return true;
  }

  return false;

  // if (pixelGrid[x][y].a < 0.5) {
  //   return false;
  // }

  // // If alpha is at least 0.5, then it's an outline if all neighbors are at least 0.5
  // const neighbors = [
  //   {x: x - 1, y: y},
  //   {x: x + 1, y: y},
  //   {x: x, y: y - 1},
  //   {x: x, y: y + 1},
  // ];

  // return neighbors.every(neighbor => !pixelGrid[neighbor.x]?.[neighbor.y] || pixelGrid[neighbor.x]?.[neighbor.y]?.a >= 0.5);
}

function addStartingPixel(x, y) {
  addFillPixel(x, y, STARTING_HUE, STARTING_SATURATION, STARTING_LIGHTNESS);
}

async function grow(x, y, erase = false, erasingOutline = false) {
  if (!growthActive) {
    brushPixelsChanged = false;
    fillPixelsChanged = false;

    if (!erase) {
      addStartingPixel(x, y);
    } else {
      erasePixel(x, y, erasingOutline);
    }

    growthActive = true;
    let growths = 1;

    while (blooms.size) {
      growBranch(erase, erasingOutline);

      if (growths % (DELAY_THRESHOLD * 1) === 0) {
        drawFillImageData();
      }

      if (growths % DELAY_THRESHOLD === 0) {
        await step();
      }

      growths++;
    }

    stopGrowth();
  } else {
    addStartingPixel(x, y);
  }
}

function getFillCanvas() {
  return fillCanvasHistory[fillHistoryIndex];
}

function getBrushCanvas() {
  return brushCanvasHistory[brushHistoryIndex];
}

function getFillImageData() {
  return fillImageDataHistory[fillHistoryIndex];
}

function getFillPixelGrid() {
  return fillPixelGridHistory[fillHistoryIndex];
}

function getBrushPixelGrid() {
  return brushPixelGridHistory[brushHistoryIndex];
}

function setNewFillPixelGrid() {
  fillPixelGridHistory[fillHistoryIndex] = Array.from({length: CANVAS_WIDTH}, () => Array.from({length: CANVAS_HEIGHT}));
}

function setNewBrushPixelGrid() {
  brushPixelGridHistory[brushHistoryIndex] = Array.from({length: CANVAS_WIDTH}, () => Array.from({length: CANVAS_HEIGHT}));
}

function storeFillCanvas() {
  const canvas = getFillCanvas();
  const canvasCopy = document.createElement("canvas");
  canvasCopy.classList.add("fill-canvas");
  canvasCopy.width = canvas.width;
  canvasCopy.height = canvas.height;
  const ctx = canvasCopy.getContext("2d", {willReadFrequently: true});
  ctx.drawImage(canvas, 0, 0);

  fillImageDataHistory.unshift(ctx.getImageData(0, 0, canvas.width, canvas.height));
  fillCanvasHistory.unshift(canvasCopy);
  document.getElementById("canvasWrapper").appendChild(canvasCopy);
  canvas.style.display = "none";
}

function storeBrushCanvas() {
  const canvas = getBrushCanvas();
  const canvasCopy = document.createElement("canvas");
  canvasCopy.classList.add("brush-canvas");
  canvasCopy.width = canvas.width;
  canvasCopy.height = canvas.height;
  const ctx = canvasCopy.getContext("2d");
  ctx.drawImage(canvas, 0, 0);

  brushCanvasHistory.unshift(canvasCopy);
  document.getElementById("canvasWrapper").appendChild(canvasCopy);
  canvas.style.display = "none";
}

function removeAllRedos() {
  if (fillHistoryIndex > 0) {
    fillPixelGridHistory.splice(0, fillHistoryIndex);
    fillImageDataHistory.splice(0, fillHistoryIndex);
    const canvases = fillCanvasHistory.splice(0, fillHistoryIndex);
    fillHistoryIndex = 0;

    for (const canvas of canvases) {
      canvas.remove();
    }
  }

  if (brushHistoryIndex > 0) {
    brushPixelGridHistory.splice(0, brushHistoryIndex);
    const canvases = brushCanvasHistory.splice(0, brushHistoryIndex);
    brushHistoryIndex = 0;

    for (const canvas of canvases) {
      canvas.remove();
    }
  }
}

function storeFillHistory() {
  removeAllRedos();

  // Store a copy of the 2D array and canvas
  fillPixelGridHistory.unshift(structuredClone(getFillPixelGrid()));
  storeFillCanvas();

  /* if (fillPixelGridHistory.length > HISTORY_LIMIT) {
    fillPixelGridHistory.pop();
    fillImageDataHistory.pop();
  }

  if (fillCanvasHistory.length > HISTORY_LIMIT) {
    const canvas = fillCanvasHistory.pop();
    canvas.remove();
  } */
}

function storeBrushHistory() {
  removeAllRedos();

  // Store a copy of the 2D array and canvas
  brushPixelGridHistory.unshift(structuredClone(getBrushPixelGrid()));
  storeBrushCanvas();

  /* if (brushPixelGridHistory.length > HISTORY_LIMIT) {
    brushPixelGridHistory.pop();
  }

  if (brushCanvasHistory.length > HISTORY_LIMIT) {
    const canvas = brushCanvasHistory.pop();
    canvas.remove();
  } */
}

function storeCombinedHistory(historyType) {
  // Remove all redos
  if (combinedHistoryIndex > 0) {
    combinedHistory.splice(0, combinedHistoryIndex);
    combinedHistoryIndex = 0;
  }

  combinedHistory.unshift(historyType);

  if (combinedHistory.length > HISTORY_LIMIT) {
    combinedHistory.pop();
  }

  if (fillPixelGridHistory.length > HISTORY_LIMIT) {
    fillPixelGridHistory.pop();
    fillImageDataHistory.pop();
    const fillCanvas = fillCanvasHistory.pop();
    fillCanvas.remove();
  }

  if (brushPixelGridHistory.length > HISTORY_LIMIT) {
    brushPixelGridHistory.pop();
    const brushCanvas = brushCanvasHistory.pop();
    brushCanvas.remove();
  }

  // console.log(combinedHistoryIndex, combinedHistory);
  updateHistoryButtons();
}

// eslint-disable-next-line no-unused-vars
async function share() {
  if (!interactive) {
    return;
  }

  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;

  const ctx = canvas.getContext('2d');
  ctx.drawImage(getFillCanvas(), 0, 0, canvas.width, canvas.height);
  ctx.drawImage(getBrushCanvas(), 0, 0, canvas.width, canvas.height);

  const blob = await new Promise(resolve => {
    canvas.toBlob(resolve, 'image/webp');
  });

  const file = new File([blob], 'color-bloom-wallpaper.webp', { type: 'image/webp' });

  const shareData = {
    title: 'Color Bloom',
    text: 'I made some special art!',
    files: [file],
    url: '/art.html',
  };

  await navigator.share(shareData);

  canvas.remove();
}

// eslint-disable-next-line no-unused-vars
function download() {
  if (!interactive) {
    return;
  }

  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;

  const ctx = canvas.getContext('2d');
  ctx.drawImage(getFillCanvas(), 0, 0, canvas.width, canvas.height);
  ctx.drawImage(getBrushCanvas(), 0, 0, canvas.width, canvas.height);

  const link = document.createElement('a');
  link.download = 'color-bloom-wallpaper';
  // Default quality webp is about 3/5ths the file size of a default quality jpeg,
  // and about 1/6th the file size of full quality webp, jpeg, or png.
  // For 1920x1080, that's about 750KB, 1.25MB, and 4.5MB respectively.
  link.href = canvas.toDataURL('image/webp');
  link.click();
  link.remove();

  canvas.remove();
}

function undo() {
  if (!interactive) {
    return;
  }

  if (combinedHistoryIndex < combinedHistory.length - 1) {
    const historyType = combinedHistory[combinedHistoryIndex]

    if (historyType === "fill" || historyType === "both") {
      undoFill();
    }

    if (historyType === "brush" || historyType === "both") {
      undoBrush();
    }

    saveCanvasData();

    combinedHistoryIndex++;
    updateHistoryButtons();
    announceForScreenReader("Change undone.");
  } else {
    announceForScreenReader("No change to undo.");
  }
}

function undoFill(allowRedo = true) {
  if (fillPixelGridHistory.length - 1 > fillHistoryIndex) {
    stopGrowth();

    if (allowRedo) {
      getFillCanvas().style.display = "none";
      fillHistoryIndex++;
    } else /* if (fillPixelGridHistory.length > 1) */ {
      getFillCanvas().remove();
      fillPixelGridHistory.splice(fillHistoryIndex, 1);
      fillImageDataHistory.splice(fillHistoryIndex, 1);
      fillCanvasHistory.splice(fillHistoryIndex, 1);

      if (combinedHistory[combinedHistoryIndex] === "fill") {
        combinedHistory.splice(combinedHistoryIndex, 1);
      } else if (combinedHistory[combinedHistoryIndex] === "both") {
        combinedHistory[combinedHistoryIndex] = "brush";
      }

      updateHistoryButtons();
    }

    getFillCanvas().style.display = null
  }
}

function undoBrush(allowRedo = true) {
  if (brushPixelGridHistory.length - 1 > brushHistoryIndex) {
    stopGrowth();

    if (allowRedo) {
      getBrushCanvas().style.display = "none";
      brushHistoryIndex++;
    } else /* if (brushPixelGridHistory.length > 1) */ {
      getBrushCanvas().remove();
      brushPixelGridHistory.splice(brushHistoryIndex, 1);
      brushCanvasHistory.splice(brushHistoryIndex, 1);

      if (combinedHistory[combinedHistoryIndex] === "brush") {
        combinedHistory.splice(combinedHistoryIndex, 1);
      } else if (combinedHistory[combinedHistoryIndex] === "both") {
        combinedHistory[combinedHistoryIndex] = "fill";
      }

      updateHistoryButtons();
    }

    getBrushCanvas().style.display = null;
  }
}

function redo() {
  if (!interactive) {
    return;
  }

  /* const toolbarData = getToolbarData();
  const selectedTool = toolbarData.tool;

  if (selectedTool === "brush") {
    redoBrush();
  } else {
    redoFill();
  } */

  if (combinedHistoryIndex > 0) {
    combinedHistoryIndex--;
    const historyType = combinedHistory[combinedHistoryIndex];

    if (historyType === "fill" || historyType === "both") {
      redoFill();
    }

    if (historyType === "brush" || historyType === "both") {
      redoBrush();
    }

    saveCanvasData();
    updateHistoryButtons();
    announceForScreenReader("Change redone.");
  } else {
    announceForScreenReader("No change to redo.");
  }
}

function redoFill() {
  if (fillHistoryIndex > 0) {
    stopGrowth();
    getFillCanvas().style.display = "none";
    fillHistoryIndex--;
    getFillCanvas().style.display = null;
    // updateHistoryButtons();
  }
}

function redoBrush() {
  if (brushHistoryIndex > 0) {
    stopGrowth();
    getBrushCanvas().style.display = "none";
    brushHistoryIndex--;
    getBrushCanvas().style.display = null;
    // updateHistoryButtons();
  }
}

function updateHistoryButtons() {
  /* const toolbarData = getToolbarData();
  const selectedTool = toolbarData.tool;

  let historyIndex = fillHistoryIndex;
  let pixelGridHistory = fillPixelGridHistory;

  if (selectedTool === "brush") {
    historyIndex = brushHistoryIndex;
    pixelGridHistory = brushPixelGridHistory;
  }

  document.getElementById("undoButton").disabled = historyIndex >= pixelGridHistory.length - 1;
  document.getElementById("redoButton").disabled = historyIndex <= 0; */

  document.getElementById("undoButton").disabled = combinedHistoryIndex >= combinedHistory.length - 1;
  document.getElementById("redoButton").disabled = combinedHistoryIndex <= 0;
}

/* async function syncCanvasToPixelGrid() {
  const canvas = getFillCanvas();
  const context = canvas.getContext("2d");
  context.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

  let counter = 1;

  for (let x = 0; x < CANVAS_WIDTH; x++) {
    for (let y = 0; y < CANVAS_HEIGHT; y++) {
      const pixel = getFillPixelGrid()[x][y];

      if (pixel) {
        context.fillStyle = `hsl(${pixel.h}, ${pixel.s * 100}%, ${pixel.l * 100}%)`;
        context.fillRect(x, y, 1, 1);

        if (counter % DELAY_THRESHOLD === 0) {
          await step();
        }

        counter++;
      }
    }
  }
} */

function getImageDataIndex(x, y, canvasWidth) {
  return (y * canvasWidth + x) * 4;
}

function assignImageDataPixel(imageData, hslPixel) {
  const index = getImageDataIndex(hslPixel.x, hslPixel.y, imageData.width);
  const {r, g, b} = hsl2rgb(hslPixel.h, hslPixel.s, hslPixel.l);

  imageData.data[index] = r;
  imageData.data[index + 1] = g;
  imageData.data[index + 2] = b;
  imageData.data[index + 3] = (hslPixel.a ?? 1) * 255;
}

function drawFillImageData() {
  const imageData = getFillImageData();
  const canvas = getFillCanvas();
  const context = canvas.getContext("2d");
  context.putImageData(imageData, 0, 0);
}

async function syncPixelGridToBrushCanvas() {
  const canvas = getBrushCanvas();
  const context = canvas.getContext("2d", {willReadFrequently: true});
  context.shadowBlur = 0;
  const previousPixelGrid = brushPixelGridHistory[brushHistoryIndex + 1];
  const {data} = context.getImageData(0, 0, canvas.width, canvas.height);

  brushPixelGridHistory[brushHistoryIndex] = Array.from({length: CANVAS_WIDTH},
      (_elX, x) => Array.from({length: CANVAS_HEIGHT}, (_elY, y) => {
    const index = (y * CANVAS_WIDTH + x) * 4;
    // TODO - support other colors?
    // const r = data[index];
    // const g = data[index + 1];
    // const b = data[index + 2];
    const a = data[index + 3] / 255;

    // let {h, s, l} = rgb2hsl(r, g, b);

    // if (a > 0.2 && l < 0.5) {
    //   const pixel = {x: i, y: j, h: 0, s: 0, l: 0};
    //   pixelGrid[i][j] = pixel;
    //   drawPixel(pixel, getBrushCanvas());
    // }

    const pixel = a > 0 ? {x, y, h: 0, s: 0, l: 0, a} : undefined;

    // TODO - support other colors?
    if (previousPixelGrid[x][y] && !pixel || pixel && !previousPixelGrid[x][y]
        || pixel?.a !== previousPixelGrid[x][y]?.a) {
      brushPixelsChanged = true;
    }

    return pixel;
  }));
}

function resetCanvas() {
  if (!interactive) {
    return;
  }

  stopGrowth();

  let historyType = "";

  if (getFillPixelGrid().flat().some(pixel => pixel)) {
    storeFillHistory();
    setNewFillPixelGrid();
    const fillCanvas = getFillCanvas();
    const fillContext = fillCanvas.getContext("2d", {willReadFrequently: true});
    fillContext.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    fillImageDataHistory.unshift(fillContext.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT));
    historyType = "fill";
  }

  if (getBrushPixelGrid().flat().some(pixel => pixel)) {
    storeBrushHistory();
    setNewBrushPixelGrid();
    getBrushCanvas().getContext("2d").clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    historyType = historyType === "fill" ? "both" : "brush";
  }

  if (historyType) {
    storeCombinedHistory(historyType);
  }

  announceForScreenReader('Canvas reset.');
}

function setCssVar(name, value) {
  document.documentElement.style.setProperty(name, value);
}

function getCssVar(name) {
  return getComputedStyle(document.documentElement).getPropertyValue(name);
}

function onFillColorChange(event) {
  setCssVar('--selected-fill-color', event.currentTarget.value);
}

function onFillColorFocus() {
  if (document.querySelector(':focus-visible')) {
    announceForScreenReader('Color for Fill');
  }
}

function onRangeValueChange(event, spanId, displayAsPercent = true) {
  const valueSpan = document.getElementById(spanId);
  valueSpan.innerText = displayAsPercent ?
      `${Math.floor(event.currentTarget.value * 100 / event.currentTarget.max)}%` : event.currentTarget.value;

  if (displayAsPercent) {
    event.currentTarget.ariaValueText = valueSpan.innerText;
  }
}

let smoothScaleAnimationId = null;

function smoothScale(targetScale) {
  function scaleStep() {
    cancelAnimationFrame(smoothScaleAnimationId);
    const canvasScale = parseFloat(getCssVar('--canvas-scale'));

    if (Math.abs(canvasScale - targetScale) < 0.005) {
      setCssVar('--canvas-scale', targetScale);

      // Update for new offset limits
      setRelativeCanvasOffsetsWithLimits(0, 0);
      smoothScaleAnimationId = null;
      return;
    }

    const delta = (targetScale - canvasScale) * 0.25;
    const sign = Math.sign(delta);
    const absDelta = Math.abs(delta);

    setCssVar('--canvas-scale', canvasScale + sign * Math.max(absDelta, 0.004));

    // Update for new offset limits
    setRelativeCanvasOffsetsWithLimits(0, 0);
    smoothScaleAnimationId = requestAnimationFrame(scaleStep);
  }

  cancelAnimationFrame(smoothScaleAnimationId);
  smoothScaleAnimationId = requestAnimationFrame(scaleStep);
}

function onCanvasScaleValueChange(value) {
  const valueSpan = document.getElementById('canvasScaleValue');
  valueSpan.innerText = `${value}%`;
  const slider = document.getElementById('canvasScale');
  slider.ariaValueText = valueSpan.innerText;

  smoothScale(value / 100);
}

function getCanvasCoordinates(mouseX, mouseY) {
  const canvas = getFillCanvas();
  const scale = parseFloat(getCssVar('--canvas-scale'));

  let {x, y} = canvas.getBoundingClientRect();
  x = Math.round((mouseX - x) / scale);
  y = Math.round((mouseY - y) / scale);

  return {x, y};
}

function convertToMouseCoordinates(canvasX, canvasY) {
  const canvas = getFillCanvas();
  const scale = parseFloat(getCssVar('--canvas-scale'));

  const {x, y} = canvas.getBoundingClientRect();
  return {x: x + canvasX * scale, y: y + canvasY * scale};
}

function handleClick(clickX, clickY, fromMove = false) {
  if (document.getElementById("toolbar").classList.contains("hidden")) {
    return;
  }

  let {x, y} = getCanvasCoordinates(clickX, clickY);

  if (x >= 0 && x < CANVAS_WIDTH
      && y >= 0 && y < CANVAS_HEIGHT) {
    const toolbarData = getToolbarData();
    const selectedTool = toolbarData.tool;

    if (selectedTool === "fill") {
      if (!getFillPixelGrid()[x][y]?.a && !countsAsOutlineAt(x, y)) {
        if (!growthActive) {
          const {h, s, l} = getStartingColor();
          STARTING_HUE = h;
          STARTING_SATURATION = s;
          STARTING_LIGHTNESS = l;

          HUE_MUTATION = toolbarData.hueMutation;
          SATURATION_MUTATION = toolbarData.saturationMutation;
          LIGHTNESS_MUTATION = toolbarData.valueMutation;

          if (!fillPixelsChanged) {
            storeFillHistory();
            storeCombinedHistory("fill");
          }
        }

        grow(x, y);
      } else if (!fromMove && !isFilling && growthActive) {
        stopGrowth();
      } else if (!growthActive) {
        // Give leeway equal to have the fill size
        const fillSize = parseInt(toolbarData.fillSize) / 2;

        if (!isNaN(fillSize)) {
          const halfSize = Math.ceil(fillSize * 0.5);

          for (let i = Math.max(0, x - halfSize); i <= Math.min(CANVAS_WIDTH - 1, x + halfSize); i++) {
            for (let j = Math.max(0, y - halfSize); j <= Math.min(CANVAS_HEIGHT - 1, y + halfSize); j++) {
              // If point is not further from (x, y) than halfSize
              if (Math.pow(i - x, 2) + Math.pow(j - y, 2) <= Math.pow(halfSize, 2)) {
                if (!getFillPixelGrid()[i][j]?.a && !countsAsOutlineAt(i, j)) {
                  const {x: mouseX, y: mouseY} = convertToMouseCoordinates(i, j);
                  handleClick(mouseX, mouseY, fromMove);
                  return;
                }
              }
            }
          }
        }
      }
    } else if (selectedTool === "erase") {
      if (getFillPixelGrid()[x][y]?.a || getBrushPixelGrid()[x][y]?.a) {
        const fillingNotStarted = erasingOutlineForMousePress == null;

        if (fillingNotStarted) {
          erasingOutlineForMousePress = !!getBrushPixelGrid()[x][y];
        } else if (erasingOutlineForMousePress && !getBrushPixelGrid()[x][y]?.a) {
          return;
        }

        if (!growthActive) {
          if (fillingNotStarted || (!fillPixelsChanged && !brushPixelsChanged)) {
            if (erasingOutlineForMousePress) {
              storeBrushHistory();
            }

            storeFillHistory();
            storeCombinedHistory(erasingOutlineForMousePress ? "both" : "fill");
          }
        }

        grow(x, y, true, erasingOutlineForMousePress);
      } else if (!fromMove && !isFilling && growthActive) {
        stopGrowth();
      } else if (!growthActive) {
        // Give leeway equal to have the erase size
        const eraseSize = parseInt(toolbarData.eraseSize) / 2;

        if (!isNaN(eraseSize)) {
          const halfSize = Math.ceil(eraseSize * 0.5);

          for (let i = Math.max(0, x - halfSize); i <= Math.min(CANVAS_WIDTH - 1, x + halfSize); i++) {
            for (let j = Math.max(0, y - halfSize); j <= Math.min(CANVAS_HEIGHT - 1, y + halfSize); j++) {
              // If point is not further from (x, y) than halfSize
              if (Math.pow(i - x, 2) + Math.pow(j - y, 2) <= Math.pow(halfSize, 2)) {
                if (getFillPixelGrid()[i][j]?.a || getBrushPixelGrid()[i][j]?.a) {
                  const {x: mouseX, y: mouseY} = convertToMouseCoordinates(i, j);
                  handleClick(mouseX, mouseY, fromMove);
                  return;
                }
              }
            }
          }
        }
      }
    }
  }
}

function setRelativeCanvasOffsetsWithLimits(x, y) {
  const canvasScale = parseFloat(getCssVar('--canvas-scale'));
  const scaledWidth = CANVAS_WIDTH * canvasScale;
  const scaledHeight = CANVAS_HEIGHT * canvasScale;

  const viewportRequirementX = window.innerWidth * 0.2;
  const viewportRequirementY = window.innerHeight * 0.2;

  const maxOffscreenX = scaledWidth * 0.5 - viewportRequirementX;
  const maxOffscreenY = scaledHeight * 0.5 - viewportRequirementY;

  const offsetLimitX = (window.innerWidth * 0.5 + maxOffscreenX) / canvasScale;
  const offsetLimitY = (window.innerHeight * 0.5 + maxOffscreenY) / canvasScale;

  setCssVar('--canvas-offset-x', `${Math.min(Math.max(parseInt(getCssVar('--canvas-offset-x')) + x,
      -offsetLimitX), offsetLimitX)}px`);
  setCssVar('--canvas-offset-y', `${Math.min(Math.max(parseInt(getCssVar('--canvas-offset-y')) + y,
      -offsetLimitY), offsetLimitY)}px`);
}

// const FILL_BRUSH_THROTTLE = 5;
// let fillBrushCounter = FILL_BRUSH_THROTTLE - 1;

let mouseX = NaN;
let mouseY = NaN;

function onCanvasMouseMove(event) {
  const prevMouseX = mouseX;
  const prevMouseY = mouseY;

  mouseX = event.clientX;
  mouseY = event.clientY;

  const contentWrapper = document.getElementById("contentWrapper");

  if (!contentWrapper) {
    return;
  }

  const draggingCanvas = event.buttons !== 1 && contentWrapper.classList.contains("positioning");
  const shouldDrag = draggingCanvas && interactive;

  if (shouldDrag) {
    const canvasScale = parseFloat(getCssVar('--canvas-scale'));
    const deltaX = mouseX - prevMouseX;
    const deltaY = mouseY - prevMouseY;

    storedMovementX += (isNaN(deltaX) ? 0 : deltaX) / canvasScale;
    storedMovementY += (isNaN(deltaY) ? 0 : deltaY) / canvasScale;
  }

  if (!canvasMoveScheduled) {
    canvasMoveScheduled = true;

    requestAnimationFrame(() => {
      canvasMoveScheduled = false;
      setCssVar('--mouse-x', `${mouseX}px`);
      setCssVar('--mouse-y', `${mouseY}px`);

      if (shouldDrag) {
        setRelativeCanvasOffsetsWithLimits(storedMovementX, storedMovementY);
        storedMovementX = 0;
        storedMovementY = 0;
      }
    });
  }

  if (!interactive) {
    return;
  }

  // event.buttons is 1 for the primary button (left click)
  if (event.buttons === 1) {
    const selectedTool = getToolbarData().tool;

    if (isDrawing) {
      if (selectedTool === "brush") {
        let {x, y} = getCanvasCoordinates(event.x, event.y);
        addBrushstroke(x, y);
      }
    } else if (isFilling) {
      // if (growthActive) {
        // if (++fillBrushCounter % FILL_BRUSH_THROTTLE === 0) {
        //   fillBrushCounter = 0;
          clearTimeout(clickTimeoutId);
          clickTimeoutId = null;
          handleClick(event.clientX, event.clientY, true);
        // }
      // }
    }
  }
}

function onCanvasTouchMove(event) {
  event.preventDefault();

  const eventTouches = [...event.touches];

  // For testing
  // const contentWrapper = document.getElementById("contentWrapper");
  // const newTouch = new Touch({identifier: Date.now(), clientX: 100, clientY: 100, target: contentWrapper});
  // eventTouches.push(newTouch);

  const draggingCanvas = eventTouches.length > 1
      && document.getElementById("contentWrapper").classList.contains("positioning"); // Comment out for testing
  const shouldDrag = draggingCanvas; // && interactive;

  let netMovementX = 0, netMovementY = 0, totalDistance = 0, pairCount = 0;

  for (const touch of eventTouches) {
    const oldTouch = touches.get(touch.identifier);

    if (oldTouch) {
      const canvasScale = parseFloat(getCssVar('--canvas-scale'));

      netMovementX += (touch.clientX - oldTouch.clientX) / canvasScale;
      netMovementY += (touch.clientY - oldTouch.clientY) / canvasScale;

      if (shouldDrag) {
        for (const otherTouch of eventTouches) {
          if (touch.identifier === otherTouch.identifier) {
            continue;
          }

          totalDistance += Math.hypot(otherTouch.clientX - touch.clientX, otherTouch.clientY - touch.clientY);
          pairCount++;
        }
      }
    }

    touches.set(touch.identifier, {identifier: touch.identifier, clientX: touch.clientX, clientY: touch.clientY});
  }

  if (shouldDrag) {
    if (pairCount > 1) {
      netMovementX = Math.round(netMovementX / pairCount);
      netMovementY = Math.round(netMovementY / pairCount);
    }

    const averageDistance = totalDistance / pairCount;

    if (pairCount > 0 && !isNaN(startingTouchDistance) && !isNaN(startingScaleValue)) {
      const normalizationFactor = 0.25;
      const deltaDistance = (averageDistance - startingTouchDistance) * normalizationFactor;
      // Round to the nearest 5
      storedScaleValue = Math.round((startingScaleValue + deltaDistance) * 0.2) * 5;
    }

    storedMovementX += netMovementX;
    storedMovementY += netMovementY;

    if (!canvasMoveScheduled) {
      canvasMoveScheduled = true;

      requestAnimationFrame(() => {
        canvasMoveScheduled = false;

        if (storedMovementX || storedMovementY) {
          setRelativeCanvasOffsetsWithLimits(storedMovementX, storedMovementY);
          storedMovementX = 0;
          storedMovementY = 0;
        }

        if (!isNaN(storedScaleValue)) {
          const scaleInput = document.getElementById('canvasScale');
          scaleInput.value = storedScaleValue;
          onCanvasScaleValueChange(scaleInput.value);

          storedScaleValue = NaN;
        }
      });
    }
  }

  if (!interactive) {
    return;
  }

  if (eventTouches.length === 1) {
    const selectedTool = getToolbarData().tool;

    if (isDrawing) {
      if (selectedTool === "brush") {
        let {x, y} = getCanvasCoordinates(eventTouches[0].clientX, eventTouches[0].clientY);
        addBrushstroke(x, y);
      }
    } else if (isFilling) {
      clearTimeout(clickTimeoutId);
      clickTimeoutId = null;
      handleClick(eventTouches[0].clientX, eventTouches[0].clientY, true);
    }
  }
}

function viewCanvas() {
  document.getElementById("toolbar").classList.add("hidden");
  document.getElementById("settings-button").classList.add("hidden");
  document.getElementById("portfolio-link").classList.add("hidden");

  document.getElementById("canvasWrapper").focus();
  announceForScreenReader("Now viewing the canvas.");
}

function stopViewingCanvas() {
  const toolbar = document.getElementById("toolbar");

  if (toolbar.classList.contains("hidden")) {
    toolbar.classList.remove("hidden");
    document.getElementById("settings-button").classList.remove("hidden");
    document.getElementById("portfolio-link").classList.remove("hidden");

    announceForScreenReader("Stopped viewing the canvas.");
    document.getElementById("viewCanvasButton").focus();
  }
}

function onCanvasMouseDown(event) {
  previousBrushstrokePoints = [];

  if (!interactive) {
    return;
  }

  // event.buttons is 1 for the primary button (left click)
  if (event.buttons === 1) {
    clearTimeout(clickTimeoutId);
    clickTimeoutId = setTimeout(() => {
      clearTimeout(clickTimeoutId);
      clickTimeoutId = null;
    }, 200);

    const toolbar = document.getElementById("toolbar");

    if (toolbar.classList.contains("hidden")) {
      return;
    }

    const selectedTool = getToolbarData().tool;
    const {x, y} = getCanvasCoordinates(event.x, event.y);

    if (selectedTool === "brush") {
      stopGrowth();
      storeBrushHistory();
      storeCombinedHistory("brush");
      brushPixelsChanged = false;
      isDrawing = true;
      addBrushstroke(x, y);
    } else {
      if (growthActive && !(x >= 0 && x < CANVAS_WIDTH
          && y >= 0 && y < CANVAS_HEIGHT)) {
        stopGrowth();
      } else {
        isFilling = true;
      }
    }
  } else {
    document.getElementById("contentWrapper").classList.add("positioning");
  }

  setCssVar('--toolbar-pointer-events', 'none');
}

async function finishDrawing() {
  if (isDrawing) {
    isDrawing = false;

    if (allBrushstrokePoints.length) {
      pauseInteraction();

      if (previousBrushstrokePoints.length) {
        let lastPoint = previousBrushstrokePoints[0];
        const firstPoint = allBrushstrokePoints[0];
        const distance = (lastPoint.x - firstPoint.x) ** 2 + (lastPoint.y - firstPoint.y) ** 2;

        // If distance from starting point is small, use the midpoint for both
        if (allBrushstrokePoints.length > 2 && distance < getSmoothingSquaredDistance() * 0.5) {
          const midX = Math.round((lastPoint.x + firstPoint.x) * 0.5);
          const midY = Math.round((lastPoint.y + firstPoint.y) * 0.5);
          lastPoint = {x: midX, y: midY};
          firstPoint.x = midX;
          firstPoint.y = midY;
        }

        // iOS Safari won't render a line with a single point, so add a tiny offset
        allBrushstrokePoints.push({...lastPoint, x: lastPoint.x + 0.01});
      }

      const brushSize = getToolbarData().brushSize;
      const canvas = getBrushCanvas();
      const canvasContext = canvas.getContext("2d");
      const prevCanvas = brushCanvasHistory[brushHistoryIndex + 1];

      canvasContext.strokeStyle = "black";
      canvasContext.lineWidth = brushSize;
      canvasContext.shadowBlur = 0;
      canvasContext.shadowColor = canvasContext.strokeStyle;
      canvasContext.lineCap = "round";
      canvasContext.lineJoin = "round";
      canvasContext.clearRect(0, 0, canvas.width, canvas.height);
      canvasContext.drawImage(prevCanvas, 0, 0);
      canvasContext.shadowBlur = 2;

      canvasContext.beginPath();
      canvasContext.moveTo(allBrushstrokePoints[0].x, allBrushstrokePoints[0].y);

      for (let j = 0; j < allBrushstrokePoints.length - 1; j++) {
        // Calculate control points for a smooth curve
        const xc = (allBrushstrokePoints[j].x + allBrushstrokePoints[j + 1].x) * 0.5;
        const yc = (allBrushstrokePoints[j].y + allBrushstrokePoints[j + 1].y) * 0.5;

        // // Adjust line width based on velocity (faster = thinner)
        // const maxWidth = 8;
        // const minWidth = 2;
        // let lineWidth = maxWidth - (this.points[i].velocity * 0.1);
        // lineWidth = Math.max(minWidth, Math.min(maxWidth, lineWidth));

        // canvasContext.lineWidth = lineWidth;
        canvasContext.quadraticCurveTo(allBrushstrokePoints[j].x, allBrushstrokePoints[j].y, xc, yc);
      }

      canvasContext.lineTo(allBrushstrokePoints[allBrushstrokePoints.length - 1].x, allBrushstrokePoints[allBrushstrokePoints.length - 1].y);
      canvasContext.stroke();

      await syncPixelGridToBrushCanvas();
      resumeInteraction();

      allBrushstrokePoints = [];
    }

    if (!brushPixelsChanged) {
      undoBrush(false);
    }
  }
}

function pauseInteraction() {
  interactive = false;
  const form = document.getElementById("toolbar");
  form.inert = true;
  document.body.style.cursor = "wait";
}

function resumeInteraction() {
  interactive = true;
  const form = document.getElementById("toolbar");
  form.inert = false;
  document.body.style.cursor = null;
}

function onCanvasMouseUp(event) {
  setCssVar('--toolbar-pointer-events', 'all');
  document.getElementById("contentWrapper").classList.remove("positioning");

  setTimeout(() => {
    stopViewingCanvas();
  }, 50);

  // event.button is 0 for the primary button (left click)
  if (event.button === 0) {
    finishDrawing();

    if (erasingOutlineForMousePress == null) {
      // No stored fill history to undo
      isFilling = false;

      if (!growthActive) {
        fillPixelsChanged = false;
      }
    } else {
      stopFilling();
    }

    if (interactive && clickTimeoutId) {
      clearTimeout(clickTimeoutId);
      clickTimeoutId = null;

      handleClick(event.x, event.y);
    }

    saveCanvasData();
  }
}

function onCanvasTouchStart(event) {
  event.preventDefault();

  const eventTouches = [...event.touches];

  // For testing
  // const contentWrapper = document.getElementById("contentWrapper");
  // const newTouch = new Touch({identifier: Date.now(), clientX: 100, clientY: 100, target: contentWrapper});
  // eventTouches.push(newTouch);

  const scaleInput = document.getElementById('canvasScale');
  startingScaleValue = +scaleInput.value;

  previousBrushstrokePoints = [];

  if (eventTouches.length === 1) {
    for (const touch of eventTouches) {
      touches.set(touch.identifier, {identifier: touch.identifier, clientX: touch.clientX, clientY: touch.clientY});
    }

    if (interactive) {
      clearTimeout(clickTimeoutId);
      clickTimeoutId = setTimeout(() => {
        clearTimeout(clickTimeoutId);
        clickTimeoutId = null;
      }, 200);

      const toolbar = document.getElementById("toolbar");

      if (toolbar.classList.contains("hidden")) {
        return;
      }

      const selectedTool = getToolbarData().tool;
      const {x, y} = getCanvasCoordinates(eventTouches[0].clientX, eventTouches[0].clientY);

      if (selectedTool === "brush") {
        event.preventDefault();
        stopGrowth();
        storeBrushHistory();
        storeCombinedHistory("brush");
        brushPixelsChanged = false;
        isDrawing = true;
        addBrushstroke(x, y);
      } else {
        if (growthActive && !(x >= 0 && x < CANVAS_WIDTH
            && y >= 0 && y < CANVAS_HEIGHT)) {
          stopGrowth();
        } else {
          isFilling = true;
        }
      }
    }
  } else {
    clearTimeout(clickTimeoutId);
    clickTimeoutId = null;

    finishDrawing();

    if (!fillPixelsChanged) {
      // No stored fill history to undo
      isFilling = false;
    } else {
      stopFilling();
    }

    saveCanvasData();

    document.getElementById("contentWrapper").classList.add("positioning");

    let totalDistance = 0, pairCount = 0;

    for (const touch of eventTouches) {
      for (const otherTouch of eventTouches) {
        if (touch.identifier === otherTouch.identifier) {
          continue;
        }

        totalDistance += Math.hypot(otherTouch.clientX - touch.clientX, otherTouch.clientY - touch.clientY);
        pairCount++;
      }

      touches.set(touch.identifier, {identifier: touch.identifier, clientX: touch.clientX, clientY: touch.clientY});
    }

    if (pairCount > 1) {
      startingTouchDistance = totalDistance / pairCount;
    }
  }

  setCssVar('--toolbar-pointer-events', 'none');
}

function onCanvasTouchEnd(event) {
  event.preventDefault();

  for (const touch of event.changedTouches) {
    touches.delete(touch.identifier);
  }

  if (event.touches.length < 2) {
    startingTouchDistance = NaN;
    document.getElementById("contentWrapper").classList.remove("positioning");

    if (event.touches.length === 0) {
      finishDrawing();

      if (erasingOutlineForMousePress == null) {
        // No stored fill history to undo
        isFilling = false;

        if (!growthActive) {
          fillPixelsChanged = false;
        }
      } else {
        stopFilling();
      }

      setCssVar('--toolbar-pointer-events', 'all');

      setTimeout(() => {
        stopViewingCanvas();
      }, 50);

      if (interactive && clickTimeoutId) {
        clearTimeout(clickTimeoutId);
        clickTimeoutId = null;

        handleClick(event.changedTouches[0].clientX, event.changedTouches[0].clientY);
      }

      saveCanvasData();
    }
  } else if (event.touches.length > 1) {
    let totalDistance = 0, pairCount = 0;

    for (const touch of event.touches) {
      for (const otherTouch of event.touches) {
        if (touch.identifier === otherTouch.identifier) {
          continue;
        }

        totalDistance += Math.hypot(otherTouch.clientX - touch.clientX, otherTouch.clientY - touch.clientY);
        pairCount++;
      }

      touches.set(touch.identifier, {identifier: touch.identifier, clientX: touch.clientX, clientY: touch.clientY});
    }

    if (pairCount > 0) {
      const scaleInput = document.getElementById('canvasScale');
      startingScaleValue = +scaleInput.value;
      startingTouchDistance = totalDistance / pairCount;
    }
  }
}

function onCanvasMouseEnter(event) {
  // event.buttons is 1 for the primary button (left click)
  if (!interactive || event.buttons !== 1) {
    finishDrawing();
    stopFilling();
    setCssVar('--toolbar-pointer-events', 'all');
    saveCanvasData();
  }

  if (!interactive || event.buttons === 1 || event.buttons === 0) {
    document.getElementById("contentWrapper").classList.remove("positioning");
  }
}

function onCanvasMouseLeave() {
  // finishBrushstrokes();

  setCssVar('--mouse-x', `${-1000}px`);
  setCssVar('--mouse-y', `${-1000}px`);
}

function onCanvasScroll(event) {
  const scaleInput = document.getElementById('canvasScale');

  if (event.deltaY > 0) {
    scaleInput.value -= scaleInput.step;
  } else {
    scaleInput.value = +scaleInput.value + +scaleInput.step;
  }

  onCanvasScaleValueChange(scaleInput.value);
}

function onContextMenu(event) {
  event.preventDefault();
  finishDrawing();
  stopFilling();
  saveCanvasData();
}

function stopGrowth() {
  if (growthActive) {
    growthActive = false;
    blooms = new Map();

    if (!isFilling) {
      if (!fillPixelsChanged) {
        undoFill(false);
      }

      fillPixelsChanged = false;

      if (erasingOutlineForMousePress && !brushPixelsChanged) {
        undoBrush(false);
      }

      erasingOutlineForMousePress = null;
      brushPixelsChanged = false;
    }

    drawFillImageData();
    saveCanvasData();
  }
}

function stopFilling() {
  if (isFilling) {
    isFilling = false;

    if (!growthActive) {
      if (!fillPixelsChanged) {
        undoFill(false);
      }

      fillPixelsChanged = false;

      if (erasingOutlineForMousePress && !brushPixelsChanged) {
        undoBrush(false);
      }

      erasingOutlineForMousePress = null;
      brushPixelsChanged = false;
    }
  }
}

// eslint-disable-next-line no-unused-vars
function loadTemplate(filename, templateName) {
  if (!interactive) {
    return;
  }

  // Doesn't tend to get announced when placed in the image's onload...
  announceForScreenReader(`${templateName} template added.`);

  const image = new Image();
  image.crossOrigin = "anonymous";
  image.src = `images/${filename}`;
  image.onload = () => {
    imageTo2DArray(image);
  };
}

// eslint-disable-next-line no-unused-vars
function generateEllipsesPattern() {
  if (!interactive) {
    return;
  }

  stopGrowth();
  storeBrushHistory();
  storeCombinedHistory("brush");

  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;
  const ctx = canvas.getContext('2d');
  ctx.strokeStyle = 'black';
  ctx.shadowColor = ctx.strokeStyle;
  ctx.shadowBlur = 2;

  const radiusRange = Math.min(canvas.width, canvas.height) * 2;
  const minRadius = radiusRange * 0.05;
  const numCircles = 10; // Math.round(canvas.width * canvas.height / 200000);

  for (let i = 0; i < numCircles; i++) {
    const x = Math.floor(Math.random() * canvas.width * 2 - canvas.width);
    const y = Math.floor(Math.random() * canvas.height * 2 - canvas.height);
    const radiusX = Math.round(Math.random() ** 2 * radiusRange + minRadius);
    const radiusY = Math.random() < 0.5 ? radiusX : Math.round(Math.random() ** 2 * radiusRange + minRadius);
    const rotation = Math.random() * Math.PI * 2;
    const thickness = Math.floor(Math.random() * 19 + 4);

    ctx.beginPath();
    ctx.ellipse(x, y, radiusX, radiusY, rotation, 0, 2 * Math.PI);
    ctx.lineWidth = thickness;

    for (let i = 0; i < BRUSH_STROKE_REPEATS; i++) {
      ctx.stroke();
    }
  }

  const {data} = ctx.getImageData(0, 0, canvas.width, canvas.height);

  drawImageData(data);

  canvas.remove();

  announceForScreenReader("Ellipses pattern generated.");
}

// eslint-disable-next-line no-unused-vars
function generateRectanglesPattern() {
  if (!interactive) {
    return;
  }

  stopGrowth();
  storeBrushHistory();
  storeCombinedHistory("brush");

  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;
  const ctx = canvas.getContext('2d');
  ctx.strokeStyle = 'black';
  ctx.shadowColor = ctx.strokeStyle;
  ctx.shadowBlur = 2;

  const widthRange = Math.min(canvas.width, canvas.height) * 4;
  const minWidth = widthRange * 0.05;
  const numSquares = 10; // Math.round(canvas.width * canvas.height / 200000);

  for (let i = 0; i < numSquares; i++) {
    const x = Math.floor(Math.random() * canvas.width * 2 - canvas.width);
    const y = Math.floor(Math.random() * canvas.height * 2 - canvas.height);
    const width = Math.round(Math.random() ** 2 * widthRange + minWidth);
    const height = Math.random() < 0.5 ? width : Math.round(Math.random() ** 2 * widthRange + minWidth);
    const thickness = Math.floor(Math.random() * 19 + 4);

    ctx.beginPath();
    ctx.rect(x, y, width, height);
    ctx.lineWidth = thickness;

    for (let i = 0; i < BRUSH_STROKE_REPEATS; i++) {
      ctx.stroke();
    }
  }

  const {data} = ctx.getImageData(0, 0, canvas.width, canvas.height);

  drawImageData(data);

  canvas.remove();

  announceForScreenReader("Rectangles pattern generated.");
}

// eslint-disable-next-line no-unused-vars
function generateDiamondsPattern() {
  if (!interactive) {
    return;
  }

  stopGrowth();
  storeBrushHistory();
  storeCombinedHistory("brush");

  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;
  const ctx = canvas.getContext('2d');
  ctx.strokeStyle = 'black';
  ctx.shadowColor = ctx.strokeStyle;
  ctx.shadowBlur = 2;

  const widthRange = Math.min(canvas.width, canvas.height) * 4;
  const minWidth = widthRange * 0.05;
  const numSquares = 10; // Math.round(canvas.width * canvas.height / 200000);

  for (let i = 0; i < numSquares; i++) {
    const x = Math.floor(Math.random() * canvas.width * 2 - canvas.width);
    const y = Math.floor(Math.random() * canvas.height * 2 - canvas.height);
    const width = Math.round(Math.random() ** 2 * widthRange + minWidth);
    const height = Math.random() < 0.5 ? width : Math.round(Math.random() ** 2 * widthRange + minWidth);
    const thickness = Math.floor(Math.random() * 19 + 4);

    ctx.beginPath();
    ctx.translate(x, y);
    ctx.rotate(Math.PI * 0.25);
    ctx.translate(-x, -y);

    ctx.rect(x, y, width, height);
    ctx.lineWidth = thickness;

    for (let i = 0; i < BRUSH_STROKE_REPEATS; i++) {
      ctx.stroke();
    }

    ctx.translate(x, y);
    ctx.rotate(-Math.PI * 0.25);
    ctx.translate(-x, -y);
  }

  const {data} = ctx.getImageData(0, 0, canvas.width, canvas.height);

  drawImageData(data);

  canvas.remove();

  announceForScreenReader("Diamonds pattern generated.");
}

// TODO
/* function generateSpiralPattern() {
  if (!interactive) {
    return;
  }

  stopGrowth();
  storeBrushHistory();
  storeCombinedHistory("brush");

  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;
  const ctx = canvas.getContext('2d');
  ctx.strokeStyle = 'black';
  ctx.shadowColor = ctx.strokeStyle;
  ctx.shadowBlur = 2;

  const widthRange = Math.min(canvas.width, canvas.height) * 4;
  const minWidth = widthRange * 0.05;
  const numSpirals = Math.floor(Math.random() * 19) + 6;

  for (let i = 0; i < numSquares; i++) {
    const x = Math.floor(Math.random() * canvas.width * 2 - canvas.width);
    const y = Math.floor(Math.random() * canvas.height * 2 - canvas.height);
    const width = Math.round(Math.random() ** 2 * widthRange + minWidth);
    const height = Math.random() < 0.5 ? width : Math.round(Math.random() ** 2 * widthRange + minWidth);
    const thickness = Math.floor(Math.random() * 19 + 4);

    ctx.beginPath();
    ctx.translate(x, y);
    ctx.rotate(Math.PI * 0.25);
    ctx.translate(-x, -y);

    ctx.rect(x, y, width, height);
    ctx.lineWidth = thickness;

    for (let i = 0; i < BRUSH_STROKE_REPEATS; i++) {
      ctx.stroke();
    }

    ctx.translate(x, y);
    ctx.rotate(-Math.PI * 0.25);
    ctx.translate(-x, -y);
  }

  const {data} = ctx.getImageData(0, 0, canvas.width, canvas.height);

  drawImageData(data);

  canvas.remove();

  announceForScreenReader("Spiral pattern generated.");
} */

function imageTo2DArray(image) {
  stopGrowth();
  storeBrushHistory();
  storeCombinedHistory("brush");

  fillPixelsChanged = false;
  brushPixelsChanged = false;

  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;
  const ctx = canvas.getContext('2d', {willReadFrequently: true});
  ctx.imageSmoothingQuality = 'high';

  // Calculate scaling and positioning
  const imageAspectRatio = image.width / image.height;
  const canvasAspectRatio = CANVAS_WIDTH / CANVAS_HEIGHT;

  let drawWidth, drawHeight, offsetX = canvas.width * 0.1, offsetY = canvas.height * 0.1;

  if (imageAspectRatio > canvasAspectRatio) {
    // Image is wider relative to canvas
    drawWidth = canvas.width * 0.8;
    drawHeight = canvas.width * 0.8 / imageAspectRatio;
    offsetY = (canvas.height - drawHeight) * 0.5;
  } else {
    // Image is taller relative to canvas
    drawHeight = canvas.height * 0.8;
    drawWidth = canvas.height * 0.8 * imageAspectRatio;
    offsetX = (canvas.width - drawWidth) * 0.5;
  }

  ctx.drawImage(image, offsetX, offsetY, drawWidth, drawHeight);
  const {data} = ctx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

  drawImageData(data, true);

  canvas.remove();
}

function drawImageData(data, ensureOutline = false) {
  const pixelGrid = getBrushPixelGrid();
  const canvas = getBrushCanvas();
  const context = canvas.getContext("2d");
  context.shadowBlur = 0;

  for (let i = 0; i < CANVAS_WIDTH; i++) {
    for (let j = 0; j < CANVAS_HEIGHT; j++) {
      const index = (j * CANVAS_WIDTH + i) * 4;
      const r = data[index];
      const g = data[index + 1];
      const b = data[index + 2];
      let a = data[index + 3] / 255;

      let {/* h, s,  */l} = rgb2hsl(r, g, b);

      // if (a > 0.2 && l < 0.5) {
      //   const pixel = {x: i, y: j, h: 0, s: 0, l: 0};
      //   pixelGrid[i][j] = pixel;
      //   drawPixel(pixel, getBrushCanvas());
      // }

      // TODO - support other colors?
      if (a > 0 && l < 0.5) {
        if (ensureOutline && a > 0.75) {
          a = 1;
        }

        const pixel = {x: i, y: j, h: 0, s: 0, l: 0, a: Math.max(a, pixelGrid[i][j]?.a || 0)};
        pixelGrid[i][j] = pixel;

        context.fillStyle = getColorString(pixel.h, pixel.s, pixel.l, a);
        context.fillRect(pixel.x, pixel.y, 1, 1);
      }
    }
  }
}

function resetScaleAndPosition() {
  const scaleInput = document.getElementById('canvasScale');
  scaleInput.value = 50;
  onCanvasScaleValueChange(scaleInput.value);

  setCssVar('--canvas-offset-x', '0px');
  setCssVar('--canvas-offset-y', '50px');

  announceForScreenReader('Canvas scale and position reset.');
}

function openOptionInfoDialog(emojiIcon, label, description, identifier) {
  const optionInfoDialog = document.getElementById('toolbar-option-info-dialog');
  const modalContent = optionInfoDialog.querySelector('.modal-content');
  modalContent.innerHTML = `
    <h1><span aria-hidden="true">${emojiIcon} </span>${label}</h1>
    <ul>${description.split('  ').map(line => `<li>${line}</li>`).join('')}</ul>
  `;

  const shortcutCommands = shortcuts[identifier]?.commands;

  if (shortcutCommands?.length) {
    modalContent.innerHTML += `
      <h2>Keyboard Shortcut${shortcutCommands.length === 1 ? '' : 's'}</h2>
      <ul>${shortcutCommands.map((shortcut, i) => `<li>${getShortcutString(shortcut, i + 1)}</li>`).join('')}</ul>
    `;
  }

  optionInfoDialog.showModal();
}

function closeOptionInfoDialog() {
  const optionInfoDialog = document.getElementById('toolbar-option-info-dialog');
  optionInfoDialog.close();
}

function onClickOptionInfoDialogBackdrop(event) {
  if (fingerDownFromToolTipLongPress) {
    event.preventDefault();
  } else {
    closeOptionInfoDialog()
  }
}

/*
  Note: aria-keyshortcuts is not worth implementing, as its spec
  does not consistently correspond with keyboard event values,
  and a screen reader just reads the value out with no pauses or context,
  making it counterproductive when I already display the shortcuts
  in the option info dialog in a presentable, accessible way
*/
function getShortcutString(shortcut, ordinal) {
  // Meta is Windows or Command key
  const {key, code, ctrl, alt, meta, shift} = shortcut;
  const keysArray = [];

  if (meta) {
    keysArray.push('<kbd class="meta-key" title="Windows key or Command key"><span>Windows key or Command key</span></kbd>');
  }

  if (alt) {
    keysArray.push('<kbd class="alt-key" title="Alt key or Option key"><span>Alt key or Option key</span></kbd>');
  }

  if (ctrl) {
    keysArray.push('<kbd class="control-key" title="Control key"><span>Control key</span></kbd>');
  }

  if (shift) {
    keysArray.push('<kbd class="shift-key" title="Shift key"><span>Shift key</span></kbd>');
  }

  let displayedKey = key;

  if (key === 'Control' || key === 'Alt' || key === 'Meta' || key === 'Shift') {
    displayedKey = '...';
  } else if (key === ' ') {
    displayedKey = 'Space';
  } else {
    const lastChar = code.charAt(code.length - 1);
    const isNumeric = !isNaN(parseInt(lastChar));

    if (isNumeric) {
      displayedKey = lastChar;
    }
  }

  keysArray.push(`<kbd>${displayedKey}</kbd>`);

  return `<span class="sr-only">Shortcut number ${ordinal}: </span>${keysArray.join(' + ')}`;
}

function loadShortcutsData() {
  try {
    const loadedShortcutsData = localStorage.getItem("shortcuts");

    if (loadedShortcutsData) {
      const loadedShortcuts = JSON.parse(loadedShortcutsData);

      for (const action in loadedShortcuts) {
        if (shortcuts[action]) {
          shortcuts[action].commands = loadedShortcuts[action].commands;
        }
      }
    }
  } catch (e) {
    console.warn("Unable to load from local storage:", e);
  }
}

function commandsEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }

  for (let i = 0; i < a.length; i++) {
    const aCommand = a[i];
    const bCommand = b[i];
    const aEntries = Object.entries(aCommand);
    const bEntries = Object.entries(bCommand);

    if (aEntries.length !== bEntries.length) {
      return false;
    }

    for (let j = 0; j < aEntries.length; j++) {
      if (aEntries[j][0] !== bEntries[j][0] || aEntries[j][1] !== bEntries[j][1]) {
        return false;
      }
    }
  }

  return true;
}

function getCustomizedShortcuts() {
  const customizations = {};

  // Compared to for...in, safely omits prototype properties
  for (const action of Object.keys(shortcuts)) {
    const current = shortcuts[action];
    const defaults = defaultShortcuts[action];

    // If action doesn't exist in defaults, it's completely custom
    if (!defaults) {
      customizations[action] = current;
      continue;
    }

    // Compare the commands array (the important part for shortcuts)
    const currentCommands = current.commands || [];
    const defaultCommands = defaults.commands || [];

    // Check if commands are different
    const commandsChanged = !commandsEqual(currentCommands, defaultCommands);

    if (commandsChanged) {
      customizations[action] = current;
    }
  }

  return customizations;
}

function saveShortcutsData() {
  try {
    const changedShortcuts = getCustomizedShortcuts();
    localStorage.setItem('shortcuts', JSON.stringify(changedShortcuts));
  } catch (e) {
    console.warn("Unable to save to local storage:", e);
  }
}

// Takes too much memory for local storage
/* function loadCanvasImage(imageDataURL, forFill) {
  if (forFill) {
    fillPixelsChanged = false;
  } else {
    brushPixelsChanged = false;
  }

  const canvas = forFill ? getFillCanvas() : getBrushCanvas();
  canvas.src = imageDataURL;

  const image = new Image();
  image.crossOrigin = "anonymous";
  image.onload = () => {
    const pixelGrid = forFill ? getFillPixelGrid() : getBrushPixelGrid();
    const ctx = canvas.getContext('2d', {willReadFrequently: true});
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(image, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    const imageData = ctx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    const data = imageData.data;

    if (forFill) {
      fillImageDataHistory[fillHistoryIndex] = imageData;
    }

    for (let i = 0; i < CANVAS_WIDTH; i++) {
      for (let j = 0; j < CANVAS_HEIGHT; j++) {
        const index = (j * CANVAS_WIDTH + i) * 4;
        const r = data[index];
        const g = data[index + 1];
        const b = data[index + 2];
        let a = data[index + 3] / 255;

        let {h, s, l} = rgb2hsl(r, g, b);

        if (a > 0) {
          const pixel = {x: i, y: j, h, s, l, a};
          pixelGrid[i][j] = pixel;

          if (forFill) {
            fillPixelsChanged = true;
          } else {
            brushPixelsChanged = true;
          }
        }
      }
    }

    if (forFill) {
      if (!fillPixelsChanged) {
        undoFill(false);
      }
    } else if (!brushPixelsChanged) {
      undoBrush(false);
    }
  };

  image.src = imageDataURL;
} */

class CanvasIndexedDB {
  constructor(dbName = 'ColorBloomArtMaker', version = 1) {
    this.dbName = dbName;
    this.version = version;
  }

  async openDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result);

      request.onupgradeneeded = (event) => {
        const db = event.target.result;

        if (!db.objectStoreNames.contains('canvases')) {
          db.createObjectStore('canvases', { keyPath: 'id' });
        }
      };
    });
  }

  async save(canvas, id) {
    return new Promise((resolve, reject) => {
      canvas.toBlob(async (blob) => {
        try {
          const db = await this.openDB();
          const transaction = db.transaction(['canvases'], 'readwrite');
          const store = transaction.objectStore('canvases');

          await store.put({
            id: id,
            blob: blob,
            timestamp: new Date(),
            width: canvas.width,
            height: canvas.height
          });

          resolve(blob.size);
        } catch (error) {
          reject(error);
        }
      }, 'image/webp', 1); // Lossless
    });
  }

  async load(canvas, id, callback = () => {}) {
    try {
      const db = await this.openDB();

      return new Promise((resolve, reject) => {
        const transaction = db.transaction(['canvases'], 'readonly');
        const store = transaction.objectStore('canvases');
        const request = store.get(id);

        request.onsuccess = () => {
          const result = request.result;

          if (result?.blob) {
            const url = URL.createObjectURL(result.blob);
            const img = new Image();

            img.onload = () => {
              const ctx = canvas.getContext('2d');
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
              URL.revokeObjectURL(url);

              callback();
              resolve(true);
            };
            img.onerror = () => {
              URL.revokeObjectURL(url);
              reject(img.error);
            };
            img.src = url;
          } else {
            callback();
            resolve(false);
          }
        };

        request.onerror = () => {
          callback();
          reject(request.error);
        };
      });
    } catch (error) {
      console.error(`Failed to load canvas '${id}':`, error);
    }
  }
}

async function loadCanvasData() {
  if (combinedHistory.length > 1) {
    return;
  }

  if (!canvasDB) {
    canvasDB = new CanvasIndexedDB();
  }

  storeBrushHistory();
  storeFillHistory();
  storeCombinedHistory("both");

  const blankFillDataURL = getFillCanvas().toDataURL();
  const loadFillCanvasPromise = canvasDB.load(getFillCanvas(), 'fill', () => {
    const canvas = getFillCanvas();
    const newFillDataURL = canvas.toDataURL();

    if (newFillDataURL === blankFillDataURL) {
      undoFill(false);
    } else {
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;

      fillImageDataHistory[fillHistoryIndex] = imageData;

      const pixelGrid = getFillPixelGrid();

      for (let i = 0; i < CANVAS_WIDTH; i++) {
        for (let j = 0; j < CANVAS_HEIGHT; j++) {
          const index = (j * CANVAS_WIDTH + i) * 4;
          const r = data[index];
          const g = data[index + 1];
          const b = data[index + 2];
          let a = data[index + 3] / 255;

          let {h, s, l} = rgb2hsl(r, g, b);

          if (a > 0) {
            const pixel = {x: i, y: j, h, s, l, a};
            pixelGrid[i][j] = pixel;
          }
        }
      }
    }
  });

  const blankBrushDataURL = getBrushCanvas().toDataURL();
  const loadBrushCanvasPromise = canvasDB.load(getBrushCanvas(), 'brush', () => {
    const canvas = getBrushCanvas();
    const newBrushDataURL = canvas.toDataURL();

    if (newBrushDataURL === blankBrushDataURL) {
      undoBrush(false);
    } else {
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;

      const pixelGrid = getBrushPixelGrid();

      for (let i = 0; i < CANVAS_WIDTH; i++) {
        for (let j = 0; j < CANVAS_HEIGHT; j++) {
          const index = (j * CANVAS_WIDTH + i) * 4;
          const r = data[index];
          const g = data[index + 1];
          const b = data[index + 2];
          let a = data[index + 3] / 255;

          let {h, s, l} = rgb2hsl(r, g, b);

          if (a > 0) {
            const pixel = {x: i, y: j, h, s, l, a};
            pixelGrid[i][j] = pixel;
          }
        }
      }
    }
  });

  await Promise.all([document.fonts.ready, loadFillCanvasPromise, loadBrushCanvasPromise]);
  document.querySelector('main').inert = false;

  // Takes too much memory for local storage
  /* try {
    const loadedBrushCanvasData = localStorage.getItem("brushCanvas");
    const loadedFillCanvasData = localStorage.getItem("fillCanvas");

    if (loadedBrushCanvasData && loadedFillCanvasData) {
      storeBrushHistory();
      storeFillHistory();
      storeCombinedHistory("both");

      loadCanvasImage(loadedBrushCanvasData, false);
      loadCanvasImage(loadedFillCanvasData, true);
    }
  } catch (e) {
    console.warn("Unable to access local storage:", e);
  } */
}

function saveCanvasData() {
  if (!canvasDB) {
    canvasDB = new CanvasIndexedDB();
  }

  canvasDB.save(getFillCanvas(), 'fill');
  canvasDB.save(getBrushCanvas(), 'brush');

  // Takes too much memory for local storage
  /* try {
    localStorage.setItem('brushCanvas', getBrushCanvas().toDataURL('image/webp'));

    // Full quality takes a lot of memory, but it's bad to have the image degrade on load.
    // For 1920x1080, takes about 4.5 MB out of 5-10 allotted for local storage.
    localStorage.setItem('fillCanvas', getFillCanvas().toDataURL('image/webp', 1));
  } catch (e) {
    console.warn(e);
  } */
}

function loadAllData() {
  loadShortcutsData();
  loadCanvasData();
}

function refreshShortcutsDisplay() {
  const shortcutsTableBody = document.querySelector('#shortcuts-table tbody');
  let focusedRowIndex = -1;

  if (shortcutsTableBody.contains(document.activeElement)) {
    let index = 0;

    for (const row of shortcutsTableBody.children) {
      if (row.contains(document.activeElement)) {
        focusedRowIndex = index;
        break;
      }

      index++;
    }
  }

  // Important to use instead of `innerHTML = ""` for proper event listener cleanup
  shortcutsTableBody.replaceChildren();

  for (const property in shortcuts) {
    const shortcutsListId = `${property.replace('_', '-')}-shortcuts`;
    const row = document.createElement('tr');
    row.innerHTML = `
      <td>${shortcuts[property].displayName}</td>
      <td>
        <div id="${shortcutsListId}" class="shortcuts"></div>
        <span class="add-shortcut-container">
          <button aria-label="Add shortcut for '${shortcuts[property].displayName}'" class="add-shortcut"
              onclick="addShortcut(event, '${property}')">Add</button>
          <button class="awaiting-input" onclick="addShortcut(event, '${property}')">Awaiting input...</button>
        </span>
      </td>
    `;
    shortcutsTableBody.appendChild(row);

    const shortcutsList = document.getElementById(shortcutsListId);

    let index = 0;
    for (const shortcut of shortcuts[property].commands) {
      const i = index;
      const shortcutDisplay = document.createElement('div');
      shortcutDisplay.innerHTML = `<p>${getShortcutString(shortcut, i + 1)}</p>`;
      shortcutsList.appendChild(shortcutDisplay);

      const clearButton = document.createElement('button');
      clearButton.innerHTML = 'Clear';
      clearButton.ariaLabel = `Clear shortcut number ${i + 1} for '${shortcuts[property].displayName}'`;
      clearButton.addEventListener('click', () => {
        shortcuts[property].commands.splice(i, 1);
        saveShortcutsData();
        settingsAnnounceForScreenReader('Shortcut cleared.');
        refreshShortcutsDisplay();
      });

      shortcutDisplay.appendChild(clearButton);
      index++;
    }
  }

  if (focusedRowIndex > -1) {
    const row = shortcutsTableBody.children[focusedRowIndex];
    row.querySelector('button.add-shortcut').focus();
  }
}

// eslint-disable-next-line no-unused-vars
function escapeDialog(event, closeFunction) {
  if (event.key === 'Escape' && !document.querySelector('.adding-shortcut')) {
    event.preventDefault();
    closeFunction();
  }
}

let addShortcutAbortController = null;

function cleanUpAddingShortcuts() {
  const containersAddingShortcut = [...document.querySelectorAll('.adding-shortcut')];

  if (containersAddingShortcut.length) {
    addShortcutAbortController.abort();

    for (const container of containersAddingShortcut) {
      container.classList.remove('adding-shortcut');
      container.querySelector('.add-shortcut').focus();
    }
  }
}

// eslint-disable-next-line no-unused-vars
function addShortcut(event, action) {
  const container = event.currentTarget.closest('.add-shortcut-container');
  const alreadyAdding = container.classList.contains('adding-shortcut');
  const addButton = container.querySelector('.add-shortcut');
  const awaitingButton =  container.querySelector('.awaiting-input');

  cleanUpAddingShortcuts();

  if (alreadyAdding) {
    return;
  }

  addShortcutAbortController = new AbortController();

  container.classList.add('adding-shortcut');
  awaitingButton.focus();

  function captureShortcut(e) {
    e.preventDefault();
    e.stopPropagation();

    if (e.key === 'Control' || e.key === 'Alt' || e.key === 'Meta' || e.key === 'Shift') {
      return;
    }

    if (e.key !== 'Escape') {
      const newShortcut = {
        key: e.key,
        code: e.code,
        ...(e.ctrlKey && { ctrl: true }),
        ...(e.altKey && { alt: true }),
        ...(e.metaKey && { meta: true }),
        ...(e.shiftKey && { shift: true }),
      };

      shortcuts[action].commands.push(newShortcut);
      saveShortcutsData();
      settingsAnnounceForScreenReader(`Shortcut added: ${getShortcutString(newShortcut, shortcuts[action].commands.length)}`);
      refreshShortcutsDisplay();
    }

    container.classList.remove('adding-shortcut');
    addButton.focus();
    addShortcutAbortController.abort();
  }

  window.addEventListener('keydown', captureShortcut, {
    signal: addShortcutAbortController.signal,
    capture: true // Catch before other handlers
  });
}

// eslint-disable-next-line no-unused-vars
function startEditingShortcuts() {
  const shortcutsTable = document.getElementById('shortcuts-settings');
  shortcutsTable.classList.add('editing-shortcuts');
  document.getElementById('set-default-shortcuts-button').focus();
}

function stopEditingShortcuts() {
  const shortcutsTable = document.getElementById('shortcuts-settings');
  shortcutsTable.classList.remove('editing-shortcuts');
  document.getElementById('edit-shortcuts-button').focus();

  cleanUpAddingShortcuts();
}

// eslint-disable-next-line no-unused-vars
function openSettingsDialog() {
  refreshShortcutsDisplay();

  const settingsDialog = document.getElementById('settings-dialog');
  settingsDialog.showModal();
}

// eslint-disable-next-line no-unused-vars
function closeSettingsDialog() {
  const settingsDialog = document.getElementById('settings-dialog');
  settingsDialog.close();

  stopEditingShortcuts();
}

function announceForScreenReader(announcement) {
  const announcer = document.getElementById('sr-announcements');
  announcer.innerHTML = announcement;

  setTimeout(() => announcer.innerHTML = '');
}

function settingsAnnounceForScreenReader(announcement) {
  const announcer = document.getElementById('settings-sr-announcements');
  announcer.innerHTML = announcement;

  setTimeout(() => announcer.innerHTML = '');
}

// eslint-disable-next-line no-unused-vars
function setDefaultShortcuts() {
  shortcuts = structuredClone(defaultShortcuts);
  saveShortcutsData();
  refreshShortcutsDisplay();

  settingsAnnounceForScreenReader('Default shortcuts set.');
}

// eslint-disable-next-line no-unused-vars
function clearAllShortcuts() {
  for (const property in shortcuts) {
    shortcuts[property].commands = [];
  }

  saveShortcutsData();
  refreshShortcutsDisplay();

  settingsAnnounceForScreenReader('All shortcuts cleared.');
}

function setUserSelect(enabled) {
  const value = enabled ? null : 'none';
  document.body.style.userSelect = value;
  document.body.style.webkitUserSelect = value;

  const dialog = document.getElementById('toolbar-option-info-dialog');
  dialog.style.userSelect = value;
  dialog.style.webkitUserSelect = value;
}

function calculateScreenDimensions() {
  const orientation = window.screen.orientation;
  const sideways = (360 + orientation.angle) % 180 === 90;

  // Only Apple devices don't swap screen dimensions with orientation,
  // but since browser height extends fully across the screen on mobile devices
  // (even if split horizontally), we can detect when the device is sideways
  // (therefore mobile) and when browser height matches the screen width instead.
  // In this case, we want the same dimensions as portrait regardless of orientation,
  // so that loaded canvas data isn't mismatched due to orientation.
  if (sideways && window.outerHeight !== window.screen.width) {
    return {screenWidth: window.screen.height, screenHeight: window.screen.width};
  }

  return {screenWidth: window.screen.width, screenHeight: window.screen.height};
}

let fingerDownFromToolTipLongPress = false;

function init() {
  const {screenWidth, screenHeight} = calculateScreenDimensions();
  CANVAS_WIDTH = screenWidth;
  CANVAS_HEIGHT = screenHeight;

  const canvasWrapper = document.getElementById("canvasWrapper");

  const backgroundCanvas = document.createElement("canvas");
  backgroundCanvas.id = "background-canvas";
  backgroundCanvas.width = CANVAS_WIDTH;
  backgroundCanvas.height = CANVAS_HEIGHT;
  canvasWrapper.appendChild(backgroundCanvas);

  const fillCanvas = document.createElement("canvas");
  fillCanvas.classList.add("fill-canvas");
  fillCanvas.width = CANVAS_WIDTH;
  fillCanvas.height = CANVAS_HEIGHT;
  canvasWrapper.appendChild(fillCanvas);

  fillPixelGridHistory.unshift(Array.from({length: CANVAS_WIDTH}, () => Array.from({length: CANVAS_HEIGHT})));
  fillImageDataHistory.unshift(fillCanvas.getContext("2d", {willReadFrequently: true}).getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT));
  fillCanvasHistory.unshift(fillCanvas);

  const brushCanvas = document.createElement("canvas");
  brushCanvas.classList.add("brush-canvas");
  brushCanvas.width = CANVAS_WIDTH;
  brushCanvas.height = CANVAS_HEIGHT;
  canvasWrapper.appendChild(brushCanvas);

  brushPixelGridHistory.unshift(Array.from({length: CANVAS_WIDTH}, () => Array.from({length: CANVAS_HEIGHT})));
  brushCanvasHistory.unshift(brushCanvas);

  combinedHistory.unshift("");

  loadAllData();

  setCssVar('--canvas-width', `${CANVAS_WIDTH}px`);
  setCssVar('--canvas-height', `${CANVAS_HEIGHT}px`);
  setCssVar('--canvas-scale', `${getToolbarData().canvasScale / 100}`);

  // More of a nuisance than helpful, and doesn't even work on mobile
  // window.addEventListener('beforeunload', (event) => {
  //   if (historyIndex < pixelGridHistory.length - 1) {
  //     // Triggers a confirmation dialog
  //     event.preventDefault();
  //   }
  // });

  document.getElementById('shareButton').style.display = navigator.share ? null : 'none';

  const toolTipElements = [...document.querySelectorAll('#toolbar button'),
      ...document.querySelectorAll('#toolbar label:has(input:not([type=range]))')];

  for (const toolTipElement of toolTipElements) {
    toolTipElement.addEventListener('contextmenu', (event) => {
      event.preventDefault();

      const element = event.currentTarget;
      const iconWrapper = element.querySelector('& > span');

      openOptionInfoDialog(iconWrapper.innerText || iconWrapper.innerHTML, element.title, element.dataset.description, element.dataset.identifier);
    });

    // iOS Safari doesn't support contextmenu events, so need to implement long-press manually
    let longPressTimeoutId;
    let longPressTouchId;
    const globalTouches = new Map();

    document.addEventListener('touchmove', (event) => {
      for (const touch of event.changedTouches) {
        globalTouches.set(touch.identifier, touch);
      }
    });

    toolTipElement.addEventListener('touchstart', (event) => {
      for (const touch of event.changedTouches) {
        globalTouches.set(touch.identifier, touch);
      }

      const element = event.currentTarget;
      longPressTouchId = event.changedTouches[0].identifier;

      clearTimeout(longPressTimeoutId);
      longPressTimeoutId = setTimeout(() => {
        clearTimeout(longPressTimeoutId);
        longPressTimeoutId = null;
        const touch = globalTouches.get(longPressTouchId);

        if (!document.elementsFromPoint(touch.clientX, touch.clientY).includes(element)) {
          return;
        }

        // Clear any text selection that might have been triggered
        window.getSelection().removeAllRanges();

        // Temporarily disable future text selection
        setUserSelect(false);

        fingerDownFromToolTipLongPress = true;

        const iconWrapper = element.querySelector('& > span');
        openOptionInfoDialog(iconWrapper.innerText || iconWrapper.innerHTML, element.title, element.dataset.description, element.dataset.identifier);
      }, 600);
    });

    toolTipElement.addEventListener('touchend', (event) => {
      for (const touch of event.changedTouches) {
        globalTouches.delete(touch.identifier);
      }

      // For standalone apps on mobile, the option info dialog
      // would close when releasing the long press
      setTimeout(() => fingerDownFromToolTipLongPress = false, 50);

      // If the popup was opened by a long-press, prevent the context menu from triggering
      if (longPressTimeoutId == null && longPressTouchId != null) {
        for (const touch of event.changedTouches) {
          if (touch.identifier === longPressTouchId) {
            // Clear any text selection that might have been triggered
            window.getSelection().removeAllRanges();

            event.preventDefault();
            break;
          }
        }
      }

      // Re-enable text selection
      setUserSelect(true);

      clearTimeout(longPressTimeoutId);
      longPressTimeoutId = null;
      longPressTouchId = null;
    }, { passive: false });

    toolTipElement.addEventListener('touchcancel', () => {
      for (const touch of event.changedTouches) {
        globalTouches.delete(touch.identifier);
      }

      // Re-enable text selection
      setUserSelect(true);

      clearTimeout(longPressTimeoutId);
      longPressTimeoutId = null;
      longPressTouchId = null;
    });
  }
}
</script>
</head>

<body onmousemove="onCanvasMouseMove(event)">
  <div id="sr-announcements" aria-live="polite" class="sr-only"></div>

  <!-- Toolbar Info Dialog -->
  <dialog id="toolbar-option-info-dialog" aria-label="Option Info"
      onkeydown="escapeDialog(event, closeOptionInfoDialog)">
    <div class="dialog-inner-wrapper">
      <div class="modal-backdrop" onclick="onClickOptionInfoDialogBackdrop(event)"></div>
      <div class="modal-foreground">
        <button autofocus class="close-button" aria-label="Close dialog" onclick="closeOptionInfoDialog()">
          <span aria-hidden="true"></span>
        </button>

        <div class="modal-content" tabindex="-1"></div>
      </div>
    </div>
  </dialog>

  <!-- Settings Dialog -->
  <dialog id="settings-dialog" aria-labelledby="settings-title"
      onkeydown="escapeDialog(event, closeSettingsDialog)">
    <div class="dialog-inner-wrapper">
      <div id="settings-sr-announcements" aria-live="polite" class="sr-only"></div>
      <div class="modal-backdrop" onclick="closeSettingsDialog()"></div>
      <div class="modal-foreground">
        <button autofocus class="close-button" aria-label="Close dialog" onclick="closeSettingsDialog()">
          <span aria-hidden="true"></span>
        </button>

        <div class="modal-content" tabindex="-1">
          <h1 id="settings-title"><span aria-hidden="true"></span> Settings</h1>
          <section id="shortcuts-settings" aria-labelledby="shortcuts-title">
            <div id="shortcuts-title-wrapper">
              <h2 id="shortcuts-title">
                Keyboard Shortcuts
              </h2>
              <span class="row gap-small">
                <button id="edit-shortcuts-button" onclick="startEditingShortcuts()"
                    aria-label="Edit Shortcuts">Edit</button>
                <button id="set-default-shortcuts-button" onclick="setDefaultShortcuts()">Set Defaults</button>
                <button onclick="clearAllShortcuts()">Clear All</button>
              </span>
            </div>

            <fieldset inert role="presentation" aria-hidden="true" class="glossary">
              <legend>Glossary</legend>
              <dt><kbd class="meta-key"></kbd></dt> - <dd>Windows key or Command key</dd><br />
              <dt><kbd class="alt-key"></kbd></dt> - <dd>Alt key or Option key</dd><br />
              <dt><kbd class="control-key"></kbd></dt> - <dd>Control key</dd><br />
              <dt><kbd class="shift-key"></kbd></dt> - <dd>Shift key</dd>
            </fieldset>

            <table id="shortcuts-table" class="relative">
              <thead>
                <tr>
                  <th>Action</th>
                  <th>Shortcuts</th>
                </tr>
              </thead>
              <tbody id="settings-shortcuts-table"></tbody>
            </table>
          </section>
        </div>
      </div>
    </div>
  </dialog>

  <main inert>
    <form id="toolbar" aria-label="Toolbar">
      <p id="toolbar-info" class="collapsible">Right-click or long-press an option for info</p>

      <div class="outer-menu">
        <button id="viewCanvasButton" type="button" aria-label="View Canvas" title="View Canvas" onclick="viewCanvas()"
            data-identifier="view_canvas"
            data-description="Hides everything but the canvas until the next interaction.">
          <span aria-hidden="true"></span>
        </button>

        <div class="menu">
          <div role="radiogroup" aria-label="Tools">
            <label aria-label="Brush" title="Brush" data-identifier="brush"
                data-description="Select this tool to draw black outlines.  Fill and erasure blooms stop at outlines.  Erasing outlines themselves leaves the corresponding fill area blank but leaves the surrounding area untouched.  You can then fill the erased outline area as a way to effectively get colored outlines.">
              <span aria-hidden="true"></span>
              <input type="radio" name="tool" value="brush" aria-label="Brush" checked />
            </label>

            <label aria-label="Fill" title="Fill" data-identifier="fill"
                data-description="Select this tool to slowly fill a blank area with a configurable bloom of color, stopping at outlines.  Works with a single click/tap or by dragging.  Set all variances to 0 for a traditional solid fill.  Click/tap a filled area or the background outside the canvas to stop any fill blooms prematurely.">
              <span aria-hidden="true"></span>
              <input type="radio" name="tool" value="fill" aria-label="Fill" />
            </label>

            <label aria-label="Erase" title="Erase" data-identifier="erase"
                data-description="Select this tool to slowly erase filled areas or outlines, whichever is targeted first.  Works with a single click/tap or by dragging.  Click/tap a blank area or the background outside the canvas to stop any erasure blooms prematurely.">
              <span aria-hidden="true"></span>
              <input type="radio" name="tool" value="erase" aria-label="Erase" />
            </label>
          </div>

          <div class="collapsible">
            <label id="show-guidelines" aria-label="Show Guidelines" title="Show Guidelines"
                data-identifier="show_guidelines"
                data-description="When toggled on, shows lines to help target the canvas center.">
              <span aria-hidden="true"></span>
              <input type="checkbox" name="show-guidelines" aria-label="Show Guidelines" />
            </label>

            <button type="button" aria-label="Reset Scale and Position" title="Reset Scale and Position"
                onclick="resetScaleAndPosition()" data-identifier="reset_scale"
                data-description="Resets the canvas scale and position to their starting values.  In addition to the slider, canvas scale can be adjusted by pinching/spreading on a touchscreen or with the mouse wheel.  Canvas position can be adjusted by dragging with multiple fingers on a touchscreen or while holding the right or middle mouse button.">
              <span aria-hidden="true"></span>
            </button>

            <label>
              Canvas Scale
              <input type="range" id="canvasScale" name="canvasScale" min="25" max="200" value="50" step="5"
                  aria-valuetext="50%" oninput="onCanvasScaleValueChange(event.currentTarget.value)" />
              <span id="canvasScaleValue" aria-hidden="true">50%</span>
            </label>

            <button id="shareButton" type="button" aria-label="Share Canvas Image" title="Share Canvas Image"
                onclick="share()"
                data-description="Allows you to share your canvas image with others.">
              <span aria-hidden="true"></span>
            </button>

            <button id="downloadButton" type="button" aria-label="Download Canvas Image" title="Download Canvas Image" onclick="download()"
                data-description="Downloads your canvas image.  It's sized to your device's screen, so it can be used as a wallpaper.">
              <span aria-hidden="true"></span>
            </button>
          </div>

          <div>
            <button type="button" aria-label="Reset Canvas" title="Reset Canvas" onclick="resetCanvas()"
                data-identifier="reset_canvas"
                data-description="Instantly erases all filled areas and outlines.  Can be undone the same as other actions.">
              <span aria-hidden="true"></span>
            </button>

            <button id="undoButton" type="button" aria-label="Undo" title="Undo" onclick="undo()" disabled
                data-identifier="undo"
                data-description="Undoes the previous fill or outline change.  Only the last 10 changes are tracked.">
              <span aria-hidden="true"></span>
            </button>

            <button id="redoButton" type="button" aria-label="Redo" title="Redo" onclick="redo()" disabled
                data-identifier="redo"
                data-description="Redoes the most recently undone fill or outline change.">
              <span aria-hidden="true"></span>
            </button>
          </div>
        </div>

        <label id="toggle-collapse" aria-label="Toggle Toolbar Collapse" title="Toggle Toolbar Collapse"
            data-identifier="toggle_toolbar_collapse"
            data-description="Toggles between a collapsed, minimalist toolbar and the full toolbar.">
          <span aria-hidden="true">
            <span></span>
            <span></span>
          </span>
          <input type="checkbox" name="toggle-collapse" />
        </label>
      </div>

      <div class="brush-menu submenu collapsible" role="group" aria-label="Brush Submenu">
        <div>
          <label>
            Brush Size
            <input type="range" name="brushSize" min="5" max="100" value="15" step="1"
                oninput="onRangeValueChange(event, 'brushSizeValue', false)" />
            <span id="brushSizeValue" aria-hidden="true">15</span>
          </label>

          <label>
            Smoothing
            <input type="range" name="smoothing" min="0" max="1" value="0.25" step="0.05"
                aria-valuetext="25%" oninput="onRangeValueChange(event, 'smoothingValue')" />
            <span id="smoothingValue" aria-hidden="true">25%</span>
          </label>
        </div>

        <div>
          <button type="button" aria-label="Generate Ellipses Pattern" title="Generate Ellipses Pattern"
              onclick="generateEllipsesPattern()"
              data-description="Generates a random smattering of elliptical outlines.  Can be stacked or undone/reattempted as desired.">
            <span aria-hidden="true"></span>
          </button>

          <button type="button" aria-label="Generate Rectangles Pattern" title="Generate Rectangles Pattern"
              onclick="generateRectanglesPattern()"
              data-description="Generates a random smattering of orthogonal outlines.  Can be stacked or undone/reattempted as desired.">
            <span aria-hidden="true"></span>
          </button>

          <button type="button" aria-label="Generate Diamonds Pattern" title="Generate Diamonds Pattern"
              onclick="generateDiamondsPattern()"
              data-description="Generates a random smattering of diagonal outlines.  Can be stacked or undone/reattempted as desired.">
            <span aria-hidden="true"></span>
          </button>
        </div>

        <div>
          <button type="button" aria-label="Add Heart Rose Template" title="Add Heart Rose Template"
              onclick="loadTemplate('heart-rose.png', 'Heart Rose')"
              data-description="Adds a heart rose template outline, centered on the canvas.">
            <span aria-hidden="true"></span>
          </button>

          <button type="button" aria-label="Add Palm Tree Template" title="Add Palm Tree Template"
              onclick="loadTemplate('palm-tree.png', 'Palm Tree')"
              data-description="Adds a palm tree template outline, centered on the canvas.">
            <span aria-hidden="true"></span>
          </button>
        </div>
      </div>

      <div class="fill-menu submenu collapsible" role="group" aria-label="Fill Submenu">
        <div>
          <label id="limitless-fill" aria-label="Limitless Fill" title="Limitless Fill"
              data-description="Toggle this off to restrict each fill bloom to a configured size and also allow for some targeting leeway to easily fill in stray blank spots.">
            <span aria-hidden="true"></span>
            <input type="checkbox" name="limitlessFill" aria-label="Limitless Fill" checked onchange="stopGrowth(); document.getElementById('fill-size').disabled = event.currentTarget.checked;" />
          </label>

          <label>
            Fill Size
            <input id="fill-size" type="range" name="fillSize" min="50" max="500" value="200" step="10"
                oninput="stopGrowth(); onRangeValueChange(event, 'fillSizeValue', false);" disabled />
            <span id="fillSizeValue" aria-hidden="true">200</span>
          </label>
        </div>

        <label aria-label="Color for Fill" title="Color for Fill" data-identifier="fill_color"
            data-description="Selects the starting color for fill blooms.">
          <span aria-hidden="true" style="visibility: hidden;"></span>
          <input type="color" name="fillColor" oninput="onFillColorChange(event)"
              onfocus="onFillColorFocus(event)" />
        </label>

        <div>
          <label>
            Hue Variance
            <input type="range" name="hueMutation" min="0" max="1" step="0.01" value="0.5"
                aria-valuetext="50%" oninput="onRangeValueChange(event, 'hueMutationValue')" />
            <span id="hueMutationValue" aria-hidden="true">50%</span>
          </label>

          <label>
            Saturation Variance
            <input type="range" name="saturationMutation" min="0" max="1" step="0.01" value="0.1"
                aria-valuetext="10%" oninput="onRangeValueChange(event, 'saturationMutationValue')" />
            <span id="saturationMutationValue" aria-hidden="true">10%</span>
          </label>

          <label>
            Lightness Variance
            <input type="range" name="valueMutation" min="0" max="1" step="0.01" value="0.5"
                aria-valuetext="50%" oninput="onRangeValueChange(event, 'lightnessMutationValue')" />
            <span id="lightnessMutationValue" aria-hidden="true">50%</span>
          </label>
        </div>
      </div>

      <div class="erase-menu submenu collapsible" role="group" aria-label="Erase Submenu">
        <div>
          <label id="limitless-erase" aria-label="Limitless Erase" title="Limitless Erase"
              data-description="Toggle this off to restrict each erasure bloom to a configured size and also allow for some targeting leeway to easily erase stray filled spots.">
            <span aria-hidden="true"></span>
            <input type="checkbox" name="limitlessErase" aria-label="Limitless Erase" checked onchange="stopGrowth(); document.getElementById('erase-size').disabled = event.currentTarget.checked;" />
          </label>

          <label>
            Erase Size
            <input id="erase-size" type="range" name="eraseSize" min="50" max="500" value="200" step="10"
                oninput="stopGrowth(); onRangeValueChange(event, 'eraseSizeValue', false);" disabled />
            <span id="eraseSizeValue" aria-hidden="true">200</span>
          </label>
        </div>
      </div>
    </form>

    <div
      id="contentWrapper"
      onmousedown="onCanvasMouseDown(event)"
      ontouchstart="onCanvasTouchStart(event)"
      onmouseup="onCanvasMouseUp(event)"
      ontouchend="onCanvasTouchEnd(event)"
      ontouchcancel="onCanvasTouchEnd(event)"
      onmouseenter="onCanvasMouseEnter(event)"
      onmouseleave="onCanvasMouseLeave(event)"
      ontouchmove="onCanvasTouchMove(event)"
      onwheel="onCanvasScroll(event)"
      oncontextmenu="onContextMenu(event)"
    >
      <div class="guide vertical center"></div>
      <div class="guide horizontal center"></div>
      <div class="guide vertical cursor"></div>
      <div class="guide horizontal cursor"></div>

      <div id="canvasWrapper" tabindex="0" aria-label="Canvas"></div>
    </div>

    <!-- Settings Button -->
    <button id="settings-button" type="button" class="collapsible" onclick="openSettingsDialog()">
      <span>
        <span aria-hidden="true"></span> Settings
      </span>
    </button>

    <!-- Portfolio Link -->
    <a id="portfolio-link" class="collapsible" href="https://alec-mitnik.github.io/"
        target="_blank" rel="author" aria-label="Check out my other projects">
      <img src="./images/PXL_Avatar_1B.jpg" alt="" />
    </a>
  </main>
</body>
</html>
