<!DOCTYPE html>
<html onmousemove="onCanvasMouseMove(event)">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<title>Color Bloom</title>

<script>
"use strict"

/* TODO:
 * - Add eraser brush, or maybe just add eraser toggle to both brush and fill, and color selection for brush
 * - Support width varying by speed of strokes or pressure of touch/stylus
 * - Support min/max thickness settings for generated patterns
 * - Support custom canvas sizes
 * - Support uploading own images as templates
 * - Unify undo/redo for brush and fill, and overhaul state/history management
 * - Add tip button
 * - Use putImageData for batch rendering?  Doesn't seem to help performance much...
 * - Consider using pointer events instead of separate mouse and touch events?  Not worth it except for getting pressure values.
 */

let CANVAS_WIDTH = 1920;
let CANVAS_HEIGHT = 1200;
const DELAY_THRESHOLD = 1000;
let STARTING_SATURATION = 1;
let SATURATION_MUTATION = 0;

// Only applies if using HSL
const MIN_LIGHTNESS = 0.0;
const MAX_LIGHTNESS = 0.6;

let LIGHTNESS_MUTATION;
let STARTING_LIGHTNESS;

const HISTORY_LIMIT = 10;
let fillImageDataHistory = [];
let fillPixelGridHistory = [];
let brushPixelGridHistory = [];
let fillCanvasHistory = [];
let brushCanvasHistory = [];
let fillHistoryIndex = 0;
let brushHistoryIndex = 0;
let branches = [];
let growthActive = false;
let erasingOutlineForMousePress;
let interactive = true;
let isDrawing = false;
let isFilling = false;
let allBrushstrokePoints = [];
let previousBrushstrokePoints = [];
let brushPixelsChanged = false;
let fillPixelsChanged = false;
let canvasMoveScheduled = false;
let storedMovementX = 0;
let storedMovementY = 0;
let storedScaleValue = NaN;
let clickTimeoutId;
const touches = new Map();
let startingTouchDistance = NaN;
let startingScaleValue = NaN;

let HUE_MUTATION;

function generateStartingHue() {
  return Math.random() * 360;
}

function getStartingColor() {
  return rgb2hsl(...hex2rgb(getToolbarData().fillColor));
}

let STARTING_HUE = generateStartingHue();

function hex2rgb(hex) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return [r, g, b];
}

function rgb2hsl(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;

  // Find min and max values
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);

  let h, s, l = (max + min) / 2;

  if (max === min) {
    // Achromatic
    h = s = 0;
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }

  return {
    h: Math.round(h * 360),
    s,
    l,
  };
}

function hsl2rgb(h, s, l) {
  h = h / 360;

  let r, g, b;

  if (s === 0) {
    // Achromatic, set to the lightness value (this is l, not 1)
    r = g = b = l;
  } else {
    // Helper function to convert hue to RGB
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };

    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;

    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255)
  };
}

function blendHslWithAlpha(baseColor, overlayColor) {
  // Convert HSL to RGB for both colors
  const baseRGB = hsl2rgb(baseColor.h, baseColor.s, baseColor.l);
  const overlayRGB = hsl2rgb(overlayColor.h, overlayColor.s, overlayColor.l);

  const blendChannel = (base, overlay, alpha) => {
    return Math.round(base * (1 - alpha) + overlay * alpha);
  };

  // Apply alpha blending in RGB space
  const resultRGB = {
    r: blendChannel(baseRGB.r, overlayRGB.r, overlayColor.a),
    g: blendChannel(baseRGB.g, overlayRGB.g, overlayColor.a),
    b: blendChannel(baseRGB.b, overlayRGB.b, overlayColor.a)
  };

  // Convert the result back to HSL
  return rgb2hsl(resultRGB.r, resultRGB.g, resultRGB.b);
}

function randIndex(arr, forSplice = false) {
  return Math.floor(Math.random() * (arr.length + (forSplice ? 1 : 0)));
}

/* function randEl(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

function removeEl(arr, el) {
  return arr.splice(arr.indexOf(el), 1)[0];
}

function pluckRandEl(arr) {
  return removeEl(arr, randEl(arr));
} */

function getToolbarData() {
  const form = document.getElementById("toolbar");
  const data = new FormData(form);
  return Object.fromEntries(data);
}

function onToolChange(event) {
  const tool = event.currentTarget.value;

  for (const submenu of document.getElementsByClassName("submenu")) {
    if (submenu.id === `${tool}-menu`) {
      submenu.classList.remove("hidden");
    } else {
      submenu.classList.add("hidden");
    }
  }

  updateHistoryButtons();
}

function step() {
  return new Promise(resolve => {
    // requestAnimationFrame(resolve);
    setTimeout(resolve);
  });
}

function getColorString(h, s, l, a = 1) {
  const colorString = `hsla(${h}, ${Math.round(s * 100)}%, ${Math.round(l * 100)}%, ${a})`;
  return colorString;
}

/* function drawPixel(pixel, canvas) {
  const context = canvas.getContext("2d");
  context.shadowBlur = 0;
  context.fillStyle = getColorString(pixel.h, pixel.s, pixel.l, pixel?.a ?? 1);
  context.fillRect(pixel.x, pixel.y, 1, 1);
} */

function addFillPixel(x, y, h, s, l) {
  const fillPixelGrid = getFillPixelGrid();
  const existingPixel = fillPixelGrid[x][y];
  let pixelToDraw = {x, y, h, s, l};

  if (existingPixel) {
    pixelToDraw = {...pixelToDraw, ...blendHslWithAlpha(pixelToDraw, existingPixel)};
  }

  // The pixel grid data needs to reflect the original color so that branches stemming from it won't be diluted.
  // Allow brushstroke to be distinguished for unfill TODO - unnecessary now?
  const pixel = {x, y, h, s, l: Math.max(l, 0.01), a: 1};
  fillPixelGrid[x][y] = pixel;
  fillPixelsChanged = true;
  // drawPixel(pixelToDraw, getFillCanvas());

  const fillImageData = getFillImageData();
  assignImageDataPixel(fillImageData, pixelToDraw);

  if (!countsAsOutlineAt(x, y)) {
    branches.splice(randIndex(branches, true), 0, pixel);
  }
}

function erasePixel(x, y, erasingOutline) {
  const fillPixelGrid = getFillPixelGrid();
  // const fillCanvas = getFillCanvas();
  // const fillCanvasContext = fillCanvas.getContext("2d");

  if (erasingOutline) {
    const brushPixelGrid = getBrushPixelGrid();
    const a = brushPixelGrid[x][y]?.a ?? 1;
    brushPixelGrid[x][y] = undefined;
    brushPixelsChanged = true;

    const brushCanvas = getBrushCanvas();
    const brushCanvasContext = brushCanvas.getContext("2d");
    brushCanvasContext.clearRect(x, y, 1, 1);

    const fillPixel = fillPixelGrid[x][y];

    if (fillPixel) {
      // fillCanvasContext.clearRect(x, y, 1, 1);

      // if (a === 1) {
      //   fillPixelGrid[x][y] = undefined;
      // } else {
        fillPixel.a *= (1 - a);
        fillPixelGrid[x][y] = fillPixel;
        // drawPixel(fillPixel, fillCanvas);
      // }

      const fillImageData = getFillImageData();
      assignImageDataPixel(fillImageData, fillPixel);

      fillPixelsChanged = true;
    }
  } else {
    fillPixelGrid[x][y] = undefined;
    // fillCanvasContext.clearRect(x, y, 1, 1);
    const fillImageData = getFillImageData();
    assignImageDataPixel(fillImageData, {x, y, h: 0, s: 0, l: 0, a: 0});
    fillPixelsChanged = true;
  }

  if (erasingOutline || !countsAsOutlineAt(x, y)) {
    branches.splice(randIndex(branches, true), 0, {x, y});
  }
}

/* function addBrushPoint(x, y, brushSize, drawPixels = false) {
  const neighborDepth = (brushSize - 1) * 0.5;
  const neighborDepthSquared = neighborDepth ** 2;
  const gridDepth = Math.ceil(neighborDepth + 4);
  // const gridDepth = Math.floor(neighborDepth);
  const gridDepthSquared = gridDepth ** 2;
  const brushSizeEven = brushSize % 2 === 0;
  const neighborOuterDepth = neighborDepth + 1;
  const neighborOuterDepthSquared = neighborOuterDepth ** 2;
  const brushPixelGrid = getBrushPixelGrid();

  for (let i = -gridDepth; i <= gridDepth; i++) {
    for (let j = -gridDepth; j <= gridDepth; j++) {
      const pixelX = x + i;
      const pixelY = y + j;

      if (pixelX < 0 || pixelX >= CANVAS_WIDTH || pixelY < 0 || pixelY >= CANVAS_HEIGHT) {
        continue;
      }

      const squares = i ** 2 + j ** 2;

      if (squares < gridDepthSquared) {
        const a = squares < neighborOuterDepthSquared ? Math.max(Math.min((neighborOuterDepth - Math.sqrt(squares)) ** 2, 1), 0.01) : 0.01;

        const pixel = {x: pixelX, y: pixelY, h: 0, s: 0, l: 0, a: Math.max(a, brushPixelGrid[pixelX][pixelY]?.a || 0)};

        brushPixelGrid[pixel.x][pixel.y] = pixel;
        brushPixelsChanged = true;

        if (drawPixels) {
          drawPixel(pixel, getBrushCanvas());
        }
      }

      // if (squares < neighborDepthSquared) {
      //   // TODO - support anti-aliasing and even brush sizes...?
      //   const pixel = {x: pixelX, y: pixelY, h: 0, s: 0, l: 0, a: 1};

      //   brushPixelGrid[pixel.x][pixel.y] = pixel;
      // }
    }
  }
} */

// TODO
const BRUSH_STROKE_REPEATS = 50;
let brushStrokeCounter = 1;
function addBrushstroke(x, y, finishing = false) {
  // brushStrokeCounter++;
  // if (brushStrokeCounter % 10 !== 0) {
  //   return;
  // }
  // brushStrokeCounter = 0;

  const brushSize = getToolbarData().brushSize - 2; // TODO
  const canvas = getBrushCanvas();

  const context = canvas.getContext("2d");
  context.strokeStyle = "black";
  context.lineWidth = brushSize - 2;
  context.lineCap = "round";
  context.lineJoin = "round"; // TODO
  // context.imageSmoothingQuality = "high";
  context.shadowColor = context.strokeStyle;
  context.shadowBlur = 2;

  // TODO
  /* if (false && previousBrushstrokePoints.length > 1) {
    const {x: refX, y: refY} = previousBrushstrokePoints[1]; // Reference point
    const {x: prevX, y: prevY} = previousBrushstrokePoints[0]; // Start point

    // if (previousBrushstroke.x !== x || previousBrushstroke.y !== y) {
      const tensionFactor = 0.5;
      const dx1 = prevX - refX;
      const dy1 = prevY - refY;
      const dx2 = x - prevX;
      const dy2 = y - prevY;

      // if (Math.abs(dx2) < 3 && Math.abs(dy2) < 3) {
      //   return;
      // }

      // const controlPointX = ((prevX + dx1 * tensionFactor) * 2 + prevX + x) / 4;
      // const controlPointY = ((prevY + dy1 * tensionFactor) * 2 + prevY + y) / 4;

      // Fill all pixels between the previous brushstroke and the current one
      // const length = Math.sqrt(dx * dx + dy * dy);
      // const stepX = dx / length;
      // const stepY = dy / length;

      // for (let i = 0; i < length; i++) {
      //   addBrushPoint(Math.round(prevX + stepX * i), Math.round(prevY + stepY * i), brushSize);
      // }


      // Calculate tangent vectors
      const tangent1 = this.getTangent(previousBrushstrokePoints[1], previousBrushstrokePoints[1]);
      const tangent2 = this.getTangent(previousBrushstrokePoints[0], {x, y});

      // Use weighted average of tangents
      const alpha = 0.5; // Balance between the two tangent directions
      const tx = (1 - alpha) * tangent1.x + alpha * tangent2.x;
      const ty = (1 - alpha) * tangent1.y + alpha * tangent2.y;

      // Distance for control point (proportional to segment length)
      const segLength = Math.sqrt(
        Math.pow(dx2, 2) + Math.pow(dy2, 2)
      );
      const ctrlDist = segLength * 0.3;

      const controlPointX = prevX + tx * ctrlDist;
      const controlPointY = prevY + ty * ctrlDist;


      // context.beginPath();
      context.moveTo(prevX, prevY);
      context.quadraticCurveTo(controlPointX, controlPointY, x, y);
      context.stroke();
      // context.closePath();

      // context.fillStyle = "blue";
      // context.beginPath();
      // context.arc(x, y, 5, 0, 2 * Math.PI);
      // context.fill();

      // context.fillStyle = "red";
      // context.beginPath();
      // context.arc(controlPointX, controlPointY, 2, 0, 2 * Math.PI);
      // context.fill();
    // }
  } else  */if (previousBrushstrokePoints.length) {
    context.beginPath();
    context.moveTo(previousBrushstrokePoints[previousBrushstrokePoints.length - 1].x, previousBrushstrokePoints[previousBrushstrokePoints.length - 1].y);

    for (let i = previousBrushstrokePoints.length - 2; i >= 0; i--) {
      context.lineTo(previousBrushstrokePoints[i].x, previousBrushstrokePoints[i].y);
    }

    context.stroke();

    // const {x: prevX, y: prevY} = previousBrushstrokePoints[0];
    // const dx = x - prevX;
    // const dy = y - prevY;

    // // Fill all pixels between the previous brushstroke and the current one
    // const length = Math.sqrt(dx * dx + dy * dy);
    // const stepX = dx / length;
    // const stepY = dy / length;

    // for (let i = 0; i < length; i++) {
    //   addBrushPoint(Math.round(prevX + stepX * i), Math.round(prevY + stepY * i), brushSize);
    // }

    // context.beginPath();
    // context.moveTo(prevX, prevY);
    // context.lineTo(x, y);
    // context.stroke();
    // context.closePath();
  } else {
    // addBrushPoint(x, y, brushSize);

    context.beginPath();
    context.moveTo(x, y);
    // iOS Safari won't render a line with a single point, so add a tiny offset
    context.lineTo(x + 0.01, y);
    context.stroke();
    // context.closePath();
  }

  previousBrushstrokePoints.unshift({x, y});

  if (previousBrushstrokePoints.length > BRUSH_STROKE_REPEATS) {
    previousBrushstrokePoints.pop();
  }

  if (!finishing) {
    const distance = (x - allBrushstrokePoints[allBrushstrokePoints.length - 1]?.x) ** 2 + (y - allBrushstrokePoints[allBrushstrokePoints.length - 1]?.y) ** 2;

    if (allBrushstrokePoints.length === 0) {
      allBrushstrokePoints.push({x, y});
      brushStrokeCounter = 1;
    } else {
      if (distance > getSmoothingSquaredDistance() || brushStrokeCounter % Math.ceil(getSmoothingSquaredDistance() * 0.005 + 1) === 0) {
        brushStrokeCounter = 1;
        allBrushstrokePoints.push({x, y});
      } else {
        brushStrokeCounter++;
      }
    }
  }
}

function getSmoothingSquaredDistance() {
  return getToolbarData().smoothing ** 3 * 50000;
}

// TODO
/* function getTangent(p1, p2) {
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  const dist = Math.sqrt(dx * dx + dy * dy);

  // Return normalized vector
  return {
    x: dist > 0 ? dx / dist : 0,
    y: dist > 0 ? dy / dist : 0
  };
} */

function mutateHue(h) {
  let actualMutation = HUE_MUTATION * 7.5;

  if (h >= 23 && h <= 27) {
    // Not enough orange
    actualMutation *= 0.5;
  } else if (h >= 100 && h <= 120) {
    // Too much green
    actualMutation *= 2;
  } else if (h >= 192 && h <= 198) {
    // Not enough light blue
    actualMutation *= 0.5;
  } else if (h >= 265 && h <= 275) {
    // Not enough purple
    if (h >= 269 && h <= 271) {
      actualMutation *= 0.25;
    } else {
      actualMutation *= 0.5;
    }
  }

  return (Math.random() * actualMutation * 2 - actualMutation + h + 360) % 360;
}

function mutateSaturation(s) {
  const actualMutation = SATURATION_MUTATION * 0.05;
  return Math.max(Math.min((Math.random() * (actualMutation * 2)) - actualMutation + s, 1), 0);
}

function mutateLightness(l, s) {
  const actualMutation = LIGHTNESS_MUTATION * 0.05;
  const newValue = (Math.random() * (actualMutation * 2)) - actualMutation + l;

  // Use max lightness value when starting lightness is 0.5 and saturation is 1,
  // and let max lightness go to 1 as these values go to 0/1 and 0 respectively
  const effectiveMaxLightness = 1 - ((1 - MAX_LIGHTNESS) * s * (1 - (2 * Math.abs(0.5 - STARTING_LIGHTNESS))));
  return Math.max(Math.min(newValue, effectiveMaxLightness), MIN_LIGHTNESS);
}

function growBranch(erase = false, erasingOutline = false) {
  // const randBranch = randEl(branches);
  const randBranch = branches.shift();

  const neighbors = [
    {x: randBranch.x - 1, y: randBranch.y},
    {x: randBranch.x + 1, y: randBranch.y},
    {x: randBranch.x, y: randBranch.y - 1},
    {x: randBranch.x, y: randBranch.y + 1},
  ];

  for (const neighbor of neighbors) {
    if (neighbor.x >= 0 && neighbor.x < CANVAS_WIDTH
        && neighbor.y >= 0 && neighbor.y < CANVAS_HEIGHT) {
      if (!erase) {
        if (!(getFillPixelGrid()[neighbor.x][neighbor.y]?.a === 1) && !countsAsOutlineAt(neighbor.x, neighbor.y)) {
          addFillPixel(
            neighbor.x,
            neighbor.y,
            mutateHue(randBranch.h),
            mutateSaturation(randBranch.s),
            mutateLightness(randBranch.l, randBranch.s),
          );
        }
      } else {
        if ((erasingOutline && getBrushPixelGrid()[neighbor.x][neighbor.y])
            || (!erasingOutline && getFillPixelGrid()[neighbor.x][neighbor.y])) {
          erasePixel(neighbor.x, neighbor.y, erasingOutline);
        }
      }
    }
  };
}

function countsAsOutlineAt(x, y) {
  const pixelGrid = getBrushPixelGrid();

  if (!pixelGrid[x]?.[y]) {
    return false;
  }

  if ((pixelGrid[x][y]?.a ?? 1) > 0.985) {
    return true;
  }

  return false;

  // if (pixelGrid[x][y].a < 0.5) {
  //   return false;
  // }

  // // If alpha is at least 0.5, then it's an outline if all neighbors are at least 0.5
  // const neighbors = [
  //   {x: x - 1, y: y},
  //   {x: x + 1, y: y},
  //   {x: x, y: y - 1},
  //   {x: x, y: y + 1},
  // ];

  // return neighbors.every(neighbor => !pixelGrid[neighbor.x]?.[neighbor.y] || pixelGrid[neighbor.x]?.[neighbor.y]?.a >= 0.5);
}

function addStartingPixel(x, y) {
  addFillPixel(x, y, STARTING_HUE, STARTING_SATURATION, STARTING_LIGHTNESS);
}

async function grow(x, y, erase = false, erasingOutline = false) {
  if (!growthActive) {
    brushPixelsChanged = false;
    fillPixelsChanged = false;

    if (erase === false) {
      addStartingPixel(x, y);
    } else {
      erasePixel(x, y, erasingOutline);
    }

    growthActive = true;
    let growths = 1;

    while (branches.length) {
      growBranch(erase, erasingOutline);

      if (growths % (DELAY_THRESHOLD * 1) === 0) {
        drawFillImageData();
      }

      if (growths % DELAY_THRESHOLD === 0) {
        await step();
      }

      growths++;
    }

    stopGrowth();
  } else {
    // TODO
    addStartingPixel(x, y);
  }
}

function getFillCanvas() {
  return fillCanvasHistory[fillHistoryIndex];
}

function getBrushCanvas() {
  return brushCanvasHistory[brushHistoryIndex];
}

function getFillImageData() {
  return fillImageDataHistory[fillHistoryIndex];
}

function getFillPixelGrid() {
  return fillPixelGridHistory[fillHistoryIndex];
}

function getBrushPixelGrid() {
  return brushPixelGridHistory[brushHistoryIndex];
}

function setNewFillPixelGrid() {
  fillPixelGridHistory[fillHistoryIndex] = Array.from({length: CANVAS_WIDTH}, () => Array.from({length: CANVAS_HEIGHT}));
}

function setNewBrushPixelGrid() {
  brushPixelGridHistory[brushHistoryIndex] = Array.from({length: CANVAS_WIDTH}, () => Array.from({length: CANVAS_HEIGHT}));
}

function storeFillCanvas() {
  const canvas = getFillCanvas();
  const canvasCopy = document.createElement("canvas");
  canvasCopy.classList.add("fill-canvas");
  canvasCopy.width = canvas.width;
  canvasCopy.height = canvas.height;
  const ctx = canvasCopy.getContext("2d", {willReadFrequently: true});
  ctx.drawImage(canvas, 0, 0);

  fillImageDataHistory.unshift(ctx.getImageData(0, 0, canvas.width, canvas.height));
  fillCanvasHistory.unshift(canvasCopy);
  document.getElementById("canvasWrapper").appendChild(canvasCopy);
  canvas.style.display = "none";
}

function storeBrushCanvas() {
  const canvas = getBrushCanvas();
  const canvasCopy = document.createElement("canvas");
  canvasCopy.classList.add("brush-canvas");
  canvasCopy.width = canvas.width;
  canvasCopy.height = canvas.height;
  const ctx = canvasCopy.getContext("2d");
  ctx.drawImage(canvas, 0, 0);

  brushCanvasHistory.unshift(canvasCopy);
  document.getElementById("canvasWrapper").appendChild(canvasCopy);
  canvas.style.display = "none";
}

function storeFillHistory() {
  // Remove all redos
  if (fillHistoryIndex > 0) {
    fillPixelGridHistory.splice(0, fillHistoryIndex);
    fillImageDataHistory.splice(0, fillHistoryIndex);
    const canvases = fillCanvasHistory.splice(0, fillHistoryIndex);
    fillHistoryIndex = 0;

    for (const canvas of canvases) {
      canvas.remove();
    }
  }

  // Store a copy of the 2D array and canvas
  fillPixelGridHistory.unshift(getFillPixelGrid().map(col => [...col]));
  storeFillCanvas();

  if (fillPixelGridHistory.length > HISTORY_LIMIT) {
    fillPixelGridHistory.pop();
    fillImageDataHistory.pop();
  }

  if (fillCanvasHistory.length > HISTORY_LIMIT) {
    const canvas = fillCanvasHistory.pop();
    canvas.remove();
  }
}

function storeBrushHistory() {
  // Remove all redos
  if (brushHistoryIndex > 0) {
    brushPixelGridHistory.splice(0, brushHistoryIndex);
    const canvases = brushCanvasHistory.splice(0, brushHistoryIndex);
    brushHistoryIndex = 0;

    for (const canvas of canvases) {
      canvas.remove();
    }
  }

  // Store a copy of the 2D array and canvas
  brushPixelGridHistory.unshift(getBrushPixelGrid().map(col => [...col]));
  storeBrushCanvas();

  if (brushPixelGridHistory.length > HISTORY_LIMIT) {
    brushPixelGridHistory.pop();
  }

  if (brushCanvasHistory.length > HISTORY_LIMIT) {
    const canvas = brushCanvasHistory.pop();
    canvas.remove();
  }
}

// eslint-disable-next-line no-unused-vars
async function share() {
  if (!interactive) {
    return;
  }

  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;

  const ctx = canvas.getContext('2d');
  ctx.drawImage(getFillCanvas(), 0, 0, canvas.width, canvas.height);
  ctx.drawImage(getBrushCanvas(), 0, 0, canvas.width, canvas.height);

  const blob = await new Promise(resolve => {
    canvas.toBlob(resolve, 'image/webp');
  });

  const file = new File([blob], 'color-bloom-wallpaper.webp', { type: 'image/webp' });

  const shareData = {
    title: 'Color Bloom',
    text: 'I got inspired and made some art!',
    files: [file],
    url: '/art.html',
  };

  await navigator.share(shareData);

  canvas.remove();
}

// eslint-disable-next-line no-unused-vars
function download() {
  if (!interactive) {
    return;
  }

  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;

  const ctx = canvas.getContext('2d');
  ctx.drawImage(getFillCanvas(), 0, 0, canvas.width, canvas.height);
  ctx.drawImage(getBrushCanvas(), 0, 0, canvas.width, canvas.height);

  const link = document.createElement('a');
  link.download = 'color-bloom-wallpaper';
  link.href = canvas.toDataURL(`image/webp`);
  link.click();
  link.remove();

  canvas.remove();
}

// eslint-disable-next-line no-unused-vars
function undo() {
  if (!interactive) {
    return;
  }

  const toolbarData = getToolbarData();
  const selectedTool = toolbarData.tool;

  if (selectedTool === "brush") {
    undoBrush();
  } else {
    undoFill(); // TODO - unfill?
  }
}

function undoFill(allowRedo = true) {
  if (fillPixelGridHistory.length - 1 > fillHistoryIndex) {
    stopGrowth();

    if (allowRedo) {
      getFillCanvas().style.display = "none";
      fillHistoryIndex++;
    } else {
      getFillCanvas().remove();
      fillPixelGridHistory.splice(fillHistoryIndex, 1);
      fillImageDataHistory.splice(fillHistoryIndex, 1);
      fillCanvasHistory.splice(fillHistoryIndex, 1);
    }

    getFillCanvas().style.display = null;
    updateHistoryButtons(); // TODO
  }
}

function undoBrush(allowRedo = true) {
  if (brushPixelGridHistory.length - 1 > brushHistoryIndex) {
    stopGrowth();

    if (allowRedo) {
      getBrushCanvas().style.display = "none";
      brushHistoryIndex++;
    } else {
      getBrushCanvas().remove();
      brushPixelGridHistory.splice(brushHistoryIndex, 1);
      brushCanvasHistory.splice(brushHistoryIndex, 1);
    }

    getBrushCanvas().style.display = null;
    updateHistoryButtons(); // TODO
  }
}

// eslint-disable-next-line no-unused-vars
function redo() {
  if (!interactive) {
    return;
  }

  const toolbarData = getToolbarData();
  const selectedTool = toolbarData.tool;

  if (selectedTool === "brush") {
    redoBrush();
  } else {
    redoFill(); // TODO - unfill?
  }
}

function redoFill() {
  if (fillHistoryIndex > 0) {
    stopGrowth();
    getFillCanvas().style.display = "none";
    fillHistoryIndex--;
    getFillCanvas().style.display = null;
    updateHistoryButtons(); // TODO
  }
}

function redoBrush() {
  if (brushHistoryIndex > 0) {
    stopGrowth();
    getBrushCanvas().style.display = "none";
    brushHistoryIndex--;
    getBrushCanvas().style.display = null;
    updateHistoryButtons(); // TODO
  }
}

// TODO
function updateHistoryButtons() {
  const toolbarData = getToolbarData();
  const selectedTool = toolbarData.tool;

  let historyIndex = fillHistoryIndex;
  let pixelGridHistory = fillPixelGridHistory;

  if (selectedTool === "brush") {
    historyIndex = brushHistoryIndex;
    pixelGridHistory = brushPixelGridHistory;
  }

  document.getElementById("undoButton").disabled = historyIndex >= pixelGridHistory.length - 1;
  document.getElementById("redoButton").disabled = historyIndex <= 0;
}

/* async function syncCanvasToPixelGrid() {
  const canvas = getFillCanvas();
  const context = canvas.getContext("2d");
  context.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

  let counter = 1;

  for (let x = 0; x < CANVAS_WIDTH; x++) {
    for (let y = 0; y < CANVAS_HEIGHT; y++) {
      const pixel = getFillPixelGrid()[x][y];

      if (pixel) {
        context.fillStyle = `hsl(${pixel.h}, ${pixel.s * 100}%, ${pixel.l * 100}%)`;
        context.fillRect(x, y, 1, 1);

        if (counter % DELAY_THRESHOLD === 0) {
          await step();
        }

        counter++;
      }
    }
  }
} */

function getImageDataIndex(x, y, canvasWidth) {
  return (y * canvasWidth + x) * 4;
}

function assignImageDataPixel(imageData, hslPixel) {
  const index = getImageDataIndex(hslPixel.x, hslPixel.y, imageData.width);
  const {r, g, b} = hsl2rgb(hslPixel.h, hslPixel.s, hslPixel.l);

  imageData.data[index] = r;
  imageData.data[index + 1] = g;
  imageData.data[index + 2] = b;
  imageData.data[index + 3] = (hslPixel.a ?? 1) * 255;
}

function drawFillImageData() {
  const imageData = getFillImageData();
  const canvas = getFillCanvas();
  const context = canvas.getContext("2d");
  context.putImageData(imageData, 0, 0);
}

async function syncPixelGridToBrushCanvas() {
  const canvas = getBrushCanvas();
  const context = canvas.getContext("2d", {willReadFrequently: true});
  context.shadowBlur = 0;
  const previousPixelGrid = brushPixelGridHistory[brushHistoryIndex + 1];
  const {data} = context.getImageData(0, 0, canvas.width, canvas.height);

  brushPixelGridHistory[brushHistoryIndex] = Array.from({length: CANVAS_WIDTH},
      (_elX, x) => Array.from({length: CANVAS_HEIGHT}, (_elY, y) => {
    // return previousPixelGrid[x]?.[y];

    const index = (y * CANVAS_WIDTH + x) * 4;
    // TODO - support other colors?
    // const r = data[index];
    // const g = data[index + 1];
    // const b = data[index + 2];
    const a = data[index + 3] / 255;

    // let {h, s, l} = rgb2hsl(r, g, b);

    // if (a > 0.2 && l < 0.5) {
    //   const pixel = {x: i, y: j, h: 0, s: 0, l: 0};
    //   pixelGrid[i][j] = pixel;
    //   drawPixel(pixel, getBrushCanvas());
    // }

    const pixel = a > 0 ? {x, y, h: 0, s: 0, l: 0, a} : undefined;

    // TODO - support other colors?
    if (previousPixelGrid[x][y] && !pixel || pixel && !previousPixelGrid[x][y]
          || pixel?.a !== previousPixelGrid[x][y]?.a) {
      brushPixelsChanged = true;
    }

    return pixel;
  }));

  // const pixelGrid = getBrushPixelGrid();
  // const brushRadius = Math.ceil((getToolbarData().brushSize + 2) / 2);

  // let counter = Math.floor(-DELAY_THRESHOLD / (brushRadius * 0.1));

  // for (const {x, y} of allBrushstrokePoints) {
  //   for (let i = -brushRadius; i <= brushRadius; i++) {
  //     for (let j = -brushRadius; j <= brushRadius; j++) {
  //       const pointX = x + i;
  //       const pointY = y + j;

  //       if (pointX < 0 || pointX >= canvas.width || pointY < 0 || pointY >= canvas.height) {
  //         continue;
  //       }

  //       const index = getImageDataIndex(pointX, pointY, canvas.width);
  //       let a = data[index + 3] / 255;

  //       if (a > 0) {
  //         const pixel = {x: pointX, y: pointY, h: 0, s: 0, l: 0, a: Math.max(a, pixelGrid[pointX]?.[pointY]?.a || 0)};
  //         pixelGrid[pointX][pointY] = pixel;
  //       }
  //     }
  //   }

  //   if (counter % DELAY_THRESHOLD === 0) {
  //     // console.log("awaiting");
  //     await step();
  //   }

  //   counter++;
  // }

  // for (let i = 0; i < CANVAS_WIDTH; i++) {
  //   for (let j = 0; j < CANVAS_HEIGHT; j++) {
  //     const index = (j * CANVAS_WIDTH + i) * 4;
  //     // const r = data[index];
  //     // const g = data[index + 1];
  //     // const b = data[index + 2];
  //     const a = data[index + 3] / 255;

  //     // let {h, s, l} = rgb2hsl(r, g, b);

  //     // if (a > 0.2 && l < 0.5) {
  //     //   const pixel = {x: i, y: j, h: 0, s: 0, l: 0};
  //     //   pixelGrid[i][j] = pixel;
  //     //   drawPixel(pixel, getBrushCanvas());
  //     // }

  //     // TODO - support other colors?
  //     if (a > 0) {
  //       const pixel = {x: i, y: j, h: 0, s: 0, l: 0, a};
  //       pixelGrid[i][j] = pixel;
  //     }

  //     if (counter % DELAY_THRESHOLD === 0) {
  //       await step();
  //     }

  //     counter++;
  //   }
  // }
}

// eslint-disable-next-line no-unused-vars
function resetCanvas() {
  if (!interactive) {
    return;
  }

  stopGrowth();

  if (getFillPixelGrid().flat().some(pixel => pixel)) {
    storeFillHistory();
    setNewFillPixelGrid();
    const fillCanvas = getFillCanvas();
    const fillContext = fillCanvas.getContext("2d", {willReadFrequently: true});
    fillContext.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    fillImageDataHistory.unshift(fillContext.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT));
  }

  if (getBrushPixelGrid().flat().some(pixel => pixel)) {
    storeBrushHistory();
    setNewBrushPixelGrid();
    getBrushCanvas().getContext("2d").clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
  }
}

function setCssVar(name, value) {
  document.documentElement.style.setProperty(name, value);
}

function getCssVar(name) {
  return getComputedStyle(document.documentElement).getPropertyValue(name);
}

function onFillColorChange(event) {
  setCssVar('--selected-fill-color', event.currentTarget.value);
}

function onRangeValueChange(event, spanId, displayAsPercent = true) {
  document.getElementById(spanId).innerText = displayAsPercent ?
      `${Math.floor(event.currentTarget.value * 100 / event.currentTarget.max)}%` : event.currentTarget.value;
}

function onCanvasScaleValueChange(value, spanId) {
  document.getElementById(spanId).innerText = `${value}%`;
  setCssVar('--canvas-scale', value / 100);
}

function getCanvasCoordinates(mouseX, mouseY) {
  const canvas = getFillCanvas();
  const scale = getCssVar('--canvas-scale');

  let {x, y} = canvas.getBoundingClientRect();
  x = Math.round((mouseX - x) / scale);
  y = Math.round((mouseY - y) / scale);

  return {x, y};
}

function handleClick(clickX, clickY, fromMove = false) {
  let {x, y} = getCanvasCoordinates(clickX, clickY);

  if (x >= 0 && x < CANVAS_WIDTH
      && y >= 0 && y < CANVAS_HEIGHT) {
    const toolbarData = getToolbarData();
    const selectedTool = toolbarData.tool;

    if (selectedTool === "fill") {
      if (!getFillPixelGrid()[x][y]?.a && !countsAsOutlineAt(x, y)) {
        if (!growthActive) {
          const {h, s, l} = getStartingColor();
          STARTING_HUE = h;
          STARTING_SATURATION = s;
          STARTING_LIGHTNESS = l;

          HUE_MUTATION = toolbarData.hueMutation;
          SATURATION_MUTATION = toolbarData.saturationMutation;
          LIGHTNESS_MUTATION = toolbarData.valueMutation;
        }

        grow(x, y);
      } else if (!fromMove && !isFilling) {
        stopGrowth();
      }
    } else if (selectedTool === "unfill") {
      if (erasingOutlineForMousePress == null) {
        erasingOutlineForMousePress = !!getBrushPixelGrid()[x][y];
      }

      if (getFillPixelGrid()[x][y]?.a || getBrushPixelGrid()[x][y]?.a) {
        grow(x, y, true, erasingOutlineForMousePress);
      } else if (!fromMove && !isFilling) {
        stopGrowth();
      }
    }
  }
}

// const FILL_BRUSH_THROTTLE = 5;
// let fillBrushCounter = FILL_BRUSH_THROTTLE - 1;

function onCanvasMouseMove(event) {
  const draggingCanvas = event.buttons !== 1
      && document.getElementById("contentWrapper").classList.contains("positioning");
  const shouldDrag = draggingCanvas && interactive;

  if (shouldDrag) {
    storedMovementX += event.movementX;
    storedMovementY += event.movementY;
  }

  if (!canvasMoveScheduled) {
    canvasMoveScheduled = true;
    const clientX = event.clientX;
    const clientY = event.clientY;

    requestAnimationFrame(() => {
      canvasMoveScheduled = false;
      setCssVar('--mouse-x', `${clientX}px`);
      setCssVar('--mouse-y', `${clientY}px`);

      if (shouldDrag) {
        const offsetLimitX = window.innerWidth * 0.6;
        const offsetLimitY = window.innerHeight * 0.6;
        setCssVar('--canvas-offset-x', `${Math.min(Math.max(parseInt(getCssVar('--canvas-offset-x')) + storedMovementX,
            -offsetLimitX), offsetLimitX)}px`);
        setCssVar('--canvas-offset-y', `${Math.min(Math.max(parseInt(getCssVar('--canvas-offset-y')) + storedMovementY,
            -offsetLimitY), offsetLimitY)}px`);

        storedMovementX = 0;
        storedMovementY = 0;
      }
    });
  }

  if (!interactive) {
    return;
  }

  // event.buttons is 1 for the primary button (left click)
  if (event.buttons === 1) {
    const selectedTool = getToolbarData().tool;

    if (isDrawing) {
      if (selectedTool === "brush") {
        let {x, y} = getCanvasCoordinates(event.x, event.y);
        addBrushstroke(x, y);
      }
    } else if (isFilling) {
      // if (growthActive) {
        // if (++fillBrushCounter % FILL_BRUSH_THROTTLE === 0) {
        //   fillBrushCounter = 0;
          clearTimeout(clickTimeoutId);
          clickTimeoutId = null;
          handleClick(event.clientX, event.clientY, true);
        // }
      // }
    }
  }
}

function onCanvasTouchMove(event) {
  event.preventDefault();

  const eventTouches = [...event.touches];

  // For testing
  // const contentWrapper = document.getElementById("contentWrapper");
  // const newTouch = new Touch({identifier: Date.now(), clientX: 100, clientY: 100, target: contentWrapper});
  // eventTouches.push(newTouch);

  const draggingCanvas = eventTouches.length > 1
      && document.getElementById("contentWrapper").classList.contains("positioning")
  const shouldDrag = draggingCanvas; // && interactive;

  let netMovementX = 0, netMovementY = 0, totalDistance = 0, pairCount = 0;

  for (const touch of eventTouches) {
    const oldTouch = touches.get(touch.identifier);

    if (oldTouch) {
      netMovementX += touch.clientX - oldTouch.clientX;
      netMovementY += touch.clientY - oldTouch.clientY;

      if (shouldDrag) {
        for (const otherTouch of eventTouches) {
          if (touch.identifier === otherTouch.identifier) {
            continue;
          }

          totalDistance += Math.hypot(otherTouch.clientX - touch.clientX, otherTouch.clientY - touch.clientY);
          pairCount++;
        }
      }
    }

    touches.set(touch.identifier, {identifier: touch.identifier, clientX: touch.clientX, clientY: touch.clientY});
  }

  if (shouldDrag) {
    if (pairCount > 1) {
      netMovementX = Math.round(netMovementX / pairCount);
      netMovementY = Math.round(netMovementY / pairCount);
    }

    const averageDistance = totalDistance / pairCount;

    if (pairCount > 0 && !isNaN(startingTouchDistance) && !isNaN(startingScaleValue)) {
      const deltaDistance = averageDistance - startingTouchDistance;
      // Round to the nearest 5
      storedScaleValue = Math.round((startingScaleValue + deltaDistance) * 0.2) * 5;
    }

    storedMovementX += netMovementX;
    storedMovementY += netMovementY;

    if (!canvasMoveScheduled) {
      canvasMoveScheduled = true;

      requestAnimationFrame(() => {
        canvasMoveScheduled = false;

        if (storedMovementX || storedMovementY) {
          const offsetLimitX = window.innerWidth * 0.6;
          const offsetLimitY = window.innerHeight * 0.6;
          setCssVar('--canvas-offset-x', `${Math.min(Math.max(parseInt(getCssVar('--canvas-offset-x')) + storedMovementX,
              -offsetLimitX), offsetLimitX)}px`);
          setCssVar('--canvas-offset-y', `${Math.min(Math.max(parseInt(getCssVar('--canvas-offset-y')) + storedMovementY,
              -offsetLimitY), offsetLimitY)}px`);

          storedMovementX = 0;
          storedMovementY = 0;
        }

        if (!isNaN(storedScaleValue)) {
          const scaleInput = document.getElementById('canvasScale');
          scaleInput.value = storedScaleValue;
          onCanvasScaleValueChange(scaleInput.value, 'canvasScaleValue');

          storedScaleValue = NaN;
        }
      });
    }
  }

  if (!interactive) {
    return;
  }

  if (eventTouches.length === 1) {
    const selectedTool = getToolbarData().tool;

    if (isDrawing) {
      if (selectedTool === "brush") {
        let {x, y} = getCanvasCoordinates(eventTouches[0].clientX, eventTouches[0].clientY);
        addBrushstroke(x, y);
      }
    } else if (isFilling) {
      clearTimeout(clickTimeoutId);
      clickTimeoutId = null;
      handleClick(eventTouches[0].clientX, eventTouches[0].clientY, true);
    }
  }
}

function toggleMenuCollapse(event) {
  for (const collapsible of document.getElementsByClassName("collapsible")) {
    collapsible.style.display = event.currentTarget.checked ? "none" : null;
  }
}

function toggleGuidelines() {
  for (const guide of document.getElementsByClassName("guide")) {
    guide.classList.toggle("hidden");
  }
}

// eslint-disable-next-line no-unused-vars
function viewCanvas() {
  document.getElementById("toolbar").classList.add("hidden");
}

function onCanvasMouseDown(event) {
  previousBrushstrokePoints = [];

  if (!interactive) {
    return;
  }

  // event.buttons is 1 for the primary button (left click)
  if (event.buttons === 1) {
    clearTimeout(clickTimeoutId);
    clickTimeoutId = setTimeout(() => {
      clearTimeout(clickTimeoutId);
      clickTimeoutId = null;
    }, 200);

    const toolbar = document.getElementById("toolbar");

    if (toolbar.classList.contains("hidden")) {
      return;
    }

    const selectedTool = getToolbarData().tool;
    const {x, y} = getCanvasCoordinates(event.x, event.y);

    if (selectedTool === "brush") {
      stopGrowth();
      storeBrushHistory();
      brushPixelsChanged = false;
      isDrawing = true;
      addBrushstroke(x, y);
    } else {
      if (!(x >= 0 && x < CANVAS_WIDTH
          && y >= 0 && y < CANVAS_HEIGHT)) {
        stopGrowth();
      } else {
        if (!growthActive) {
          // In case of erasing outline
          storeBrushHistory();
          storeFillHistory();
        }

        isFilling = true;
      }
    }
  } else {
    document.getElementById("contentWrapper").classList.add("positioning");
  }

  setCssVar('--toolbar-pointer-events', 'none');
}

// TODO
/* function finishBrushstrokes() {
  if (isDrawing && previousBrushstrokePoints.length) {
    const context = getBrushCanvas().getContext("2d");

    for (let i = 0; i < BRUSH_STROKE_REPEATS; i++) {
      addBrushstroke(previousBrushstrokePoints[0].x, previousBrushstrokePoints[0].y, true);
    }

    previousBrushstrokePoints = [];
    // allBrushstrokePoints = [];
  }
} */

async function finishDrawing() {
  if (isDrawing) {
    // finishBrushstrokes();
    isDrawing = false;

    if (allBrushstrokePoints.length) {
      pauseInteraction();

      if (previousBrushstrokePoints.length) {
        let lastPoint = previousBrushstrokePoints[0];
        const firstPoint = allBrushstrokePoints[0];
        const distance = (lastPoint.x - firstPoint.x) ** 2 + (lastPoint.y - firstPoint.y) ** 2;

        // If distance from starting point is small, use the midpoint for both
        if (allBrushstrokePoints.length > 2 && distance < getSmoothingSquaredDistance() * 0.5) {
          const midX = Math.round((lastPoint.x + firstPoint.x) * 0.5);
          const midY = Math.round((lastPoint.y + firstPoint.y) * 0.5);
          lastPoint = {x: midX, y: midY};
          firstPoint.x = midX;
          firstPoint.y = midY;
        }

        // iOS Safari won't render a line with a single point, so add a tiny offset
        allBrushstrokePoints.push({...lastPoint, x: lastPoint.x + 0.01});
      }

      const brushSize = getToolbarData().brushSize;
      const canvas = getBrushCanvas();
      const canvasContext = canvas.getContext("2d");
      const prevCanvas = brushCanvasHistory[brushHistoryIndex + 1];

      canvasContext.strokeStyle = "black";
      canvasContext.lineWidth = brushSize;
      canvasContext.shadowBlur = 0;
      canvasContext.shadowColor = canvasContext.strokeStyle;
      canvasContext.lineCap = "round";
      canvasContext.lineJoin = "round";
      canvasContext.clearRect(0, 0, canvas.width, canvas.height);
      canvasContext.drawImage(prevCanvas, 0, 0);
      canvasContext.shadowBlur = 2;

      canvasContext.beginPath();
      canvasContext.moveTo(allBrushstrokePoints[0].x, allBrushstrokePoints[0].y);

      for (let j = 0; j < allBrushstrokePoints.length - 1; j++) {
        // Calculate control points for a smooth curve
        const xc = (allBrushstrokePoints[j].x + allBrushstrokePoints[j + 1].x) * 0.5;
        const yc = (allBrushstrokePoints[j].y + allBrushstrokePoints[j + 1].y) * 0.5;

        // // Adjust line width based on velocity (faster = thinner)
        // const maxWidth = 8;
        // const minWidth = 2;
        // let lineWidth = maxWidth - (this.points[i].velocity * 0.1);
        // lineWidth = Math.max(minWidth, Math.min(maxWidth, lineWidth));

        // canvasContext.lineWidth = lineWidth;
        canvasContext.quadraticCurveTo(allBrushstrokePoints[j].x, allBrushstrokePoints[j].y, xc, yc);
      }

      canvasContext.lineTo(allBrushstrokePoints[allBrushstrokePoints.length - 1].x, allBrushstrokePoints[allBrushstrokePoints.length - 1].y);
      canvasContext.stroke();

      // console.log("Syncing...");
      await syncPixelGridToBrushCanvas();
      // console.log("Sync done");
      resumeInteraction();

      allBrushstrokePoints = [];
    }

    if (!brushPixelsChanged) {
      undoBrush(false);
    }

    updateHistoryButtons(); // TODO
  }
}

function pauseInteraction() {
  interactive = false;
  const form = document.getElementById("toolbar");
  form.inert = true;
  document.body.style.cursor = "wait";
}

function resumeInteraction() {
  interactive = true;
  const form = document.getElementById("toolbar");
  form.inert = false;
  document.body.style.cursor = null;
}

function onCanvasMouseUp(event) {
  setCssVar('--toolbar-pointer-events', 'all');
  document.getElementById("contentWrapper").classList.remove("positioning");

  const toolbar = document.getElementById("toolbar");
  setTimeout(() => toolbar.classList.remove("hidden"), 50);

  // event.button is 0 for the primary button (left click)
  if (event.button === 0) {
    finishDrawing();
    stopFilling();

    if (interactive && clickTimeoutId) {
      clearTimeout(clickTimeoutId);
      clickTimeoutId = null;
      handleClick(event.x, event.y);
    }
  }
}

function onCanvasTouchStart(event) {
  event.preventDefault();

  const eventTouches = [...event.touches];

  // For testing
  // const contentWrapper = document.getElementById("contentWrapper");
  // const newTouch = new Touch({identifier: Date.now(), clientX: 100, clientY: 100, target: contentWrapper});
  // eventTouches.push(newTouch);

  const scaleInput = document.getElementById('canvasScale');
  startingScaleValue = +scaleInput.value;

  previousBrushstrokePoints = [];

  if (eventTouches.length === 1) {
    for (const touch of eventTouches) {
      touches.set(touch.identifier, {identifier: touch.identifier, clientX: touch.clientX, clientY: touch.clientY});
    }

    if (interactive) {
      clearTimeout(clickTimeoutId);
      clickTimeoutId = setTimeout(() => {
        clearTimeout(clickTimeoutId);
        clickTimeoutId = null;
      }, 200);

      const toolbar = document.getElementById("toolbar");

      if (toolbar.classList.contains("hidden")) {
        return;
      }

      const selectedTool = getToolbarData().tool;
      const {x, y} = getCanvasCoordinates(eventTouches[0].clientX, eventTouches[0].clientY);

      if (selectedTool === "brush") {
        event.preventDefault();
        stopGrowth();
        storeBrushHistory();
        brushPixelsChanged = false;
        isDrawing = true;
        addBrushstroke(x, y);
      } else {
        if (!(x >= 0 && x < CANVAS_WIDTH
            && y >= 0 && y < CANVAS_HEIGHT)) {
          stopGrowth();
        } else {
          if (!growthActive) {
            // In case of erasing outline
            storeBrushHistory();
            storeFillHistory();
          }

          isFilling = true;
        }
      }
    }
  } else {
    finishDrawing();
    stopFilling();
    document.getElementById("contentWrapper").classList.add("positioning");

    let totalDistance = 0, pairCount = 0;

    for (const touch of eventTouches) {
      for (const otherTouch of eventTouches) {
        if (touch.identifier === otherTouch.identifier) {
          continue;
        }

        totalDistance += Math.hypot(otherTouch.clientX - touch.clientX, otherTouch.clientY - touch.clientY);
        pairCount++;
      }

      touches.set(touch.identifier, {identifier: touch.identifier, clientX: touch.clientX, clientY: touch.clientY});
    }

    if (pairCount > 1) {
      startingTouchDistance = totalDistance / pairCount;
    }
  }

  setCssVar('--toolbar-pointer-events', 'none');
}

function onCanvasTouchEnd(event) {
  event.preventDefault();

  for (const touch of event.changedTouches) {
    touches.delete(touch.identifier);
  }

  if (event.touches.length < 2) {
    startingTouchDistance = NaN;
    document.getElementById("contentWrapper").classList.remove("positioning");

    if (event.touches.length === 0) {
      finishDrawing();
      stopFilling();
      setCssVar('--toolbar-pointer-events', 'all');

      const toolbar = document.getElementById("toolbar");
      setTimeout(() => toolbar.classList.remove("hidden"), 50);

      if (interactive && clickTimeoutId) {
        clearTimeout(clickTimeoutId);
        clickTimeoutId = null;
        handleClick(event.changedTouches[0].clientX, event.changedTouches[0].clientY);
      }
    }
  } else if (event.touches.length > 1) {
    let totalDistance = 0, pairCount = 0;

    for (const touch of event.touches) {
      for (const otherTouch of event.touches) {
        if (touch.identifier === otherTouch.identifier) {
          continue;
        }

        totalDistance += Math.hypot(otherTouch.clientX - touch.clientX, otherTouch.clientY - touch.clientY);
        pairCount++;
      }

      touches.set(touch.identifier, {identifier: touch.identifier, clientX: touch.clientX, clientY: touch.clientY});
    }

    if (pairCount > 0) {
      const scaleInput = document.getElementById('canvasScale');
      startingScaleValue = +scaleInput.value;
      startingTouchDistance = totalDistance / pairCount;
    }
  }
}

function onCanvasMouseEnter(event) {
  // event.buttons is 1 for the primary button (left click)
  if (!interactive || event.buttons !== 1) {
    finishDrawing();
    stopFilling();
    setCssVar('--toolbar-pointer-events', 'all');
  }

  if (!interactive || event.buttons === 1 || event.buttons === 0) {
    document.getElementById("contentWrapper").classList.remove("positioning");
  }
}

function onCanvasMouseLeave() {
  // finishBrushstrokes();

  setCssVar('--mouse-x', `${-1000}px`);
  setCssVar('--mouse-y', `${-1000}px`);
}

function onCanvasScroll(event) {
  const scaleInput = document.getElementById('canvasScale');

  if (event.deltaY > 0) {
    scaleInput.value -= scaleInput.step;
  } else {
    scaleInput.value = +scaleInput.value + +scaleInput.step;
  }

  onCanvasScaleValueChange(scaleInput.value, 'canvasScaleValue');
}

function onContextMenu(event) {
  event.preventDefault();
  finishDrawing();
  stopFilling();
}

function stopGrowth() {
  if (growthActive) {
    growthActive = false;
    branches = [];

    if (!isFilling) {
      if (!fillPixelsChanged) {
        undoFill(false);
      }

      if (!brushPixelsChanged) {
        undoBrush(false);
      }

      updateHistoryButtons(); // TODO
    }

    drawFillImageData(); // TODO
  }
}

function stopFilling() {
  if (isFilling) {
    isFilling = false;

    if (!growthActive) {
      if (!fillPixelsChanged) {
        undoFill(false);
      }

      if (erasingOutlineForMousePress && !brushPixelsChanged) {
        undoBrush(false);
      }

      updateHistoryButtons(); // TODO
      drawFillImageData(); // TODO
    }

    erasingOutlineForMousePress = null;
  }
}

// eslint-disable-next-line no-unused-vars
function loadTemplate(filename) {
  if (!interactive) {
    return;
  }

  const image = new Image();
  image.crossOrigin = "anonymous";
  image.src = `images/${filename}`;
  image.onload = () => {
    imageTo2DArray(image);
  };
}

// eslint-disable-next-line no-unused-vars
function generateEllipsesPattern() {
  if (!interactive) {
    return;
  }

  stopGrowth();
  storeBrushHistory();

  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;
  const ctx = canvas.getContext('2d');
  ctx.strokeStyle = 'black';
  ctx.shadowColor = ctx.strokeStyle;
  ctx.shadowBlur = 2;

  const radiusRange = Math.min(canvas.width, canvas.height) * 2;
  const minRadius = radiusRange * 0.05;
  const numCircles = 10; // Math.round(canvas.width * canvas.height / 200000);

  for (let i = 0; i < numCircles; i++) {
    const x = Math.floor(Math.random() * canvas.width * 2 - canvas.width);
    const y = Math.floor(Math.random() * canvas.height * 2 - canvas.height);
    const radiusX = Math.round(Math.random() ** 2 * radiusRange + minRadius);
    const radiusY = Math.random() < 0.5 ? radiusX : Math.round(Math.random() ** 2 * radiusRange + minRadius);
    const rotation = Math.random() * Math.PI * 2;
    const thickness = Math.floor(Math.random() * 19 + 4);

    ctx.beginPath();
    ctx.ellipse(x, y, radiusX, radiusY, rotation, 0, 2 * Math.PI);
    ctx.lineWidth = thickness;

    for (let i = 0; i < BRUSH_STROKE_REPEATS; i++) {
      ctx.stroke();
    }
  }

  const {data} = ctx.getImageData(0, 0, canvas.width, canvas.height);

  drawImageData(data);

  canvas.remove();

  updateHistoryButtons();
}

// eslint-disable-next-line no-unused-vars
function generateRectanglesPattern() {
  if (!interactive) {
    return;
  }

  stopGrowth();
  storeBrushHistory();

  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;
  const ctx = canvas.getContext('2d');
  ctx.strokeStyle = 'black';
  ctx.shadowColor = ctx.strokeStyle;
  ctx.shadowBlur = 2;

  const widthRange = Math.min(canvas.width, canvas.height) * 4;
  const minWidth = widthRange * 0.05;
  const numSquares = 10; // Math.round(canvas.width * canvas.height / 200000);

  for (let i = 0; i < numSquares; i++) {
    const x = Math.floor(Math.random() * canvas.width * 2 - canvas.width);
    const y = Math.floor(Math.random() * canvas.height * 2 - canvas.height);
    const width = Math.round(Math.random() ** 2 * widthRange + minWidth);
    const height = Math.random() < 0.5 ? width : Math.round(Math.random() ** 2 * widthRange + minWidth);
    const thickness = Math.floor(Math.random() * 19 + 4);

    ctx.beginPath();
    ctx.rect(x, y, width, height);
    ctx.lineWidth = thickness;

    for (let i = 0; i < BRUSH_STROKE_REPEATS; i++) {
      ctx.stroke();
    }
  }

  const {data} = ctx.getImageData(0, 0, canvas.width, canvas.height);

  drawImageData(data);

  canvas.remove();

  updateHistoryButtons();
}

// eslint-disable-next-line no-unused-vars
function generateDiamondsPattern() {
  if (!interactive) {
    return;
  }

  stopGrowth();
  storeBrushHistory();

  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;
  const ctx = canvas.getContext('2d');
  ctx.strokeStyle = 'black';
  ctx.shadowColor = ctx.strokeStyle;
  ctx.shadowBlur = 2;

  const widthRange = Math.min(canvas.width, canvas.height) * 4;
  const minWidth = widthRange * 0.05;
  const numSquares = 10; // Math.round(canvas.width * canvas.height / 200000);

  for (let i = 0; i < numSquares; i++) {
    const x = Math.floor(Math.random() * canvas.width * 2 - canvas.width);
    const y = Math.floor(Math.random() * canvas.height * 2 - canvas.height);
    const width = Math.round(Math.random() ** 2 * widthRange + minWidth);
    const height = Math.random() < 0.5 ? width : Math.round(Math.random() ** 2 * widthRange + minWidth);
    const thickness = Math.floor(Math.random() * 19 + 4);

    ctx.beginPath();
    ctx.translate(x, y);
    ctx.rotate(Math.PI * 0.25);
    ctx.translate(-x, -y);

    ctx.rect(x, y, width, height);
    ctx.lineWidth = thickness;

    for (let i = 0; i < BRUSH_STROKE_REPEATS; i++) {
      ctx.stroke();
    }

    ctx.translate(x, y);
    ctx.rotate(-Math.PI * 0.25);
    ctx.translate(-x, -y);
  }

  const {data} = ctx.getImageData(0, 0, canvas.width, canvas.height);

  drawImageData(data);

  canvas.remove();

  updateHistoryButtons();
}

// TODO
/* function generateSpiralPattern() {
  if (!interactive) {
    return;
  }

  stopGrowth();
  storeBrushHistory();

  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;
  const ctx = canvas.getContext('2d');
  ctx.strokeStyle = 'black';
  ctx.shadowColor = ctx.strokeStyle;
  ctx.shadowBlur = 2;

  const widthRange = Math.min(canvas.width, canvas.height) * 4;
  const minWidth = widthRange * 0.05;
  const numSpirals = Math.floor(Math.random() * 19) + 6;

  for (let i = 0; i < numSquares; i++) {
    const x = Math.floor(Math.random() * canvas.width * 2 - canvas.width);
    const y = Math.floor(Math.random() * canvas.height * 2 - canvas.height);
    const width = Math.round(Math.random() ** 2 * widthRange + minWidth);
    const height = Math.random() < 0.5 ? width : Math.round(Math.random() ** 2 * widthRange + minWidth);
    const thickness = Math.floor(Math.random() * 19 + 4);

    ctx.beginPath();
    ctx.translate(x, y);
    ctx.rotate(Math.PI * 0.25);
    ctx.translate(-x, -y);

    ctx.rect(x, y, width, height);
    ctx.lineWidth = thickness;

    for (let i = 0; i < BRUSH_STROKE_REPEATS; i++) {
      ctx.stroke();
    }

    ctx.translate(x, y);
    ctx.rotate(-Math.PI * 0.25);
    ctx.translate(-x, -y);
  }

  const {data} = ctx.getImageData(0, 0, canvas.width, canvas.height);

  drawImageData(data);

  canvas.remove();

  updateHistoryButtons();
} */

function imageTo2DArray(image) {
  stopGrowth();
  storeBrushHistory();

  fillPixelsChanged = false;
  brushPixelsChanged = false;

  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;
  const ctx = canvas.getContext('2d', {willReadFrequently: true});

  // Calculate scaling and positioning
  const imageAspectRatio = image.width / image.height;
  const canvasAspectRatio = CANVAS_WIDTH / CANVAS_HEIGHT;

  let drawWidth, drawHeight, offsetX = CANVAS_WIDTH / 10, offsetY = CANVAS_HEIGHT / 10;

  if (imageAspectRatio > canvasAspectRatio) {
    // Image is wider relative to canvas
    drawWidth = CANVAS_WIDTH * 0.8;
    drawHeight = CANVAS_WIDTH * 0.8 / imageAspectRatio;
    offsetY = (CANVAS_HEIGHT - drawHeight) / 2;
  } else {
    // Image is taller relative to canvas
    drawHeight = CANVAS_HEIGHT * 0.8;
    drawWidth = CANVAS_HEIGHT * 0.8 * imageAspectRatio;
    offsetX = (CANVAS_WIDTH - drawWidth) / 2;
  }

  ctx.drawImage(image, offsetX, offsetY, drawWidth, drawHeight);
  const {data} = ctx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

  drawImageData(data, true);

  canvas.remove();

  updateHistoryButtons();
}

function drawImageData(data, ensureOutline = false) {
  const pixelGrid = getBrushPixelGrid();
  const canvas = getBrushCanvas();
  const context = canvas.getContext("2d");
  context.shadowBlur = 0;

  for (let i = 0; i < CANVAS_WIDTH; i++) {
    for (let j = 0; j < CANVAS_HEIGHT; j++) {
      const index = (j * CANVAS_WIDTH + i) * 4;
      const r = data[index];
      const g = data[index + 1];
      const b = data[index + 2];
      let a = data[index + 3] / 255;

      let {/* h, s,  */l} = rgb2hsl(r, g, b);

      // if (a > 0.2 && l < 0.5) {
      //   const pixel = {x: i, y: j, h: 0, s: 0, l: 0};
      //   pixelGrid[i][j] = pixel;
      //   drawPixel(pixel, getBrushCanvas());
      // }

      // TODO - support other colors?
      if (a > 0 && l < 0.5) {
        if (ensureOutline && a > 0.75) {
          a = 1;
        }

        const pixel = {x: i, y: j, h: 0, s: 0, l: 0, a: Math.max(a, pixelGrid[i][j]?.a || 0)};
        pixelGrid[i][j] = pixel;

        context.fillStyle = getColorString(pixel.h, pixel.s, pixel.l, a);
        context.fillRect(pixel.x, pixel.y, 1, 1);
      }
    }
  }
}

// eslint-disable-next-line no-unused-vars
function resetSizeAndPosition() {
  const scaleInput = document.getElementById('canvasScale');
  scaleInput.value = 50;
  onCanvasScaleValueChange(scaleInput.value, 'canvasScaleValue');

  setCssVar('--canvas-offset-x', '0px');
  setCssVar('--canvas-offset-y', '50px');
}

// eslint-disable-next-line no-unused-vars
function init() {
  CANVAS_WIDTH = window.screen.width;
  CANVAS_HEIGHT = window.screen.height;

  let canvasWrapper = document.getElementById("canvasWrapper");

  const backgroundCanvas = document.createElement("canvas");
  backgroundCanvas.id = "background-canvas";
  backgroundCanvas.width = CANVAS_WIDTH;
  backgroundCanvas.height = CANVAS_HEIGHT;
  canvasWrapper.appendChild(backgroundCanvas);

  const fillCanvas = document.createElement("canvas");
  fillCanvas.classList.add("fill-canvas");
  fillCanvas.width = CANVAS_WIDTH;
  fillCanvas.height = CANVAS_HEIGHT;
  canvasWrapper.appendChild(fillCanvas);

  fillPixelGridHistory.unshift(Array.from({length: CANVAS_WIDTH}, () => Array.from({length: CANVAS_HEIGHT})));
  fillImageDataHistory.unshift(fillCanvas.getContext("2d", {willReadFrequently: true}).getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT));
  fillCanvasHistory.unshift(fillCanvas);

  const brushCanvas = document.createElement("canvas");
  brushCanvas.classList.add("brush-canvas");
  brushCanvas.width = CANVAS_WIDTH;
  brushCanvas.height = CANVAS_HEIGHT;
  canvasWrapper.appendChild(brushCanvas);

  brushPixelGridHistory.unshift(Array.from({length: CANVAS_WIDTH}, () => Array.from({length: CANVAS_HEIGHT})));
  brushCanvasHistory.unshift(brushCanvas);

  setCssVar('--canvas-width', `${CANVAS_WIDTH}px`);
  setCssVar('--canvas-height', `${CANVAS_HEIGHT}px`);
  setCssVar('--canvas-scale', `${getToolbarData().canvasScale / 100}`);

  // More of a nuisance than helpful, and doesn't even work on mobile
  // window.addEventListener('beforeunload', (event) => {
  //   if (historyIndex < pixelGridHistory.length - 1) {
  //     // Triggers a confirmation dialog
  //     event.preventDefault();
  //   }
  // });

  document.getElementById('shareButton').style.display = navigator.share ? null : 'none';
}
</script>

<style>
*, *::before, *::after {
  box-sizing: border-box;
  flex: 0 0 auto;
  min-width: 0;
  min-height: 0;
}

:root {
  --toolbar-pointer-events: all;
  --selected-fill-color: black;
  --canvas-width: 1920px;
  --canvas-height: 1200px;
  --canvas-scale: 0.5;
  --canvas-offset-x: 0px;
  --canvas-offset-y: 50px;
  --mouse-x: -1000px;
  --mouse-y: -1000px;
  accent-color: var(--selected-fill-color);
  font-size: 100%;

  @media (width < 500px) {
    font-size: 75%;
  }
}

body, html {
  margin: 0;
  padding: 0;
  height: 100%;
  overflow: hidden;
}

body, #contentWrapper {
  display: flex;
  justify-content: center;
  align-items: center;
  background: #c7cdd1;
}

#contentWrapper {
  position: relative;
  touch-action: none;
  min-width: 100%;
  min-height: 100%;

  &.positioning {
    cursor: grabbing;
  }

  .guide {
    position: absolute;
    background: black;
    opacity: 0.1;

    &.vertical {
      transform: translateX(var(--canvas-offset-x));
      top: 0;
      bottom: 0;
      width: 2px;
    }

    &.horizontal {
      transform: translateY(var(--canvas-offset-y));
      left: 0;
      right: 0;
      height: 2px;
    }

    &.cursor {
      @media (hover: none) {
        display: none;
      }

      background-color: #0000ff;
      opacity: 0.1;
      top: -1px;
      left: -1px;

      &.vertical {
        transform: translateX(var(--mouse-x));
      }

      &.horizontal {
        transform: translateY(var(--mouse-y));
      }
    }
  }
}

#canvasWrapper {
  position: relative;
  width: calc(var(--canvas-width) * var(--canvas-scale));
  height: calc(var(--canvas-height) * var(--canvas-scale));
  transform: translate(var(--canvas-offset-x), var(--canvas-offset-y));
}

canvas {
  position: absolute;
  touch-action: none;
  background: transparent;
  width: 100%;
  height: 100%;
  z-index: 0;

  &#background-canvas {
    border: 1px solid rgba(0, 0, 0, 0.3);
    background: white url('images/45degree_fabric.webp');
    background-clip: content-box;
    box-shadow: 0 5px 20px 10px rgba(0, 0, 0, 0.2);
  }

  &.brush-canvas {
    z-index: 1;
  }
}

#contentWrapper, canvas {
  user-select: none;
}

#toolbar {
  font-family: sans-serif;
  pointer-events: var(--toolbar-pointer-events);
  position: fixed;
  top: 10px;
  z-index: 10;
  padding: 15px;
  border-radius: 10px;
  box-shadow: 0 5px 10px 2px rgba(0, 0, 0, 0.5);
  max-width: calc(100% - 20px);
  background: rgba(184, 209, 235, 0.9);
  color: black;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: 10px;

  &[inert] {
    opacity: 0.5;
    pointer-events: none;
  }

  div {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 10px;
    flex-wrap: wrap;
    max-width: 100%;
  }

  .outer-menu {
    align-items: flex-start;
    flex-wrap: nowrap;
  }

  .menu {
    flex-wrap: wrap-reverse;
    flex: 1;
  }

  label:not(:has(input[type="range"])), button {
    border: 4px solid transparent;
    background-color: rgb(0, 0, 0, 0.25);
    background-clip: padding-box;
    padding: 2px;
    font-size: 2rem;
    position: relative;
    border-radius: 8px;
  }

  :has(#toggle-collapse :checked) label:has([value="fill"]:checked) {
    border-color: var(--selected-fill-color) !important;
  }

  label:not(:has(input[type="range"])) {
    cursor: pointer;

    &:not(#toggle-collapse):has(:checked) {
      background-color: black;
      border-color: white;
    }

    &:has([type="color"]) {
      border-color: var(--selected-fill-color);
    }

    @media (hover: hover) {
      &:hover {
        background-color: black;
      }
    }

    input {
      appearance: none;
      background: transparent;
      margin: 0;
      padding: 0;
      border: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
  }

  label#toggle-collapse {
    &::before {
      content: '➖';
    }

    &:has(:checked)::before {
      content: '➕';
    }
  }

  label:has(input[type="range"]) {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  input:not([type="text"]) {
    &:not(:disabled) {
      cursor: pointer;
    }
  }

  button {
    appearance: none;
    cursor: pointer;
    color: inherit;
    font-family: inherit;

    @media (hover: hover) {
      &:hover:not(:disabled) {
        background-color: black;
      }
    }

    &:disabled {
      opacity: 0.5;
      cursor: default;
    }
  }

  button, input {
    /* Prevent double-tap from zooming in on mobile */
    touch-action: manipulation;
  }
}

.hidden {
  display: none !important;
}
</style>
</head>

<body onload="init()">
  <form id="toolbar">
    <div class="outer-menu">
      <button type="button" aria-label="View Canvas" title="View Canvas" onclick="viewCanvas()">👁️</button>

      <div class="menu">
        <div>
          <label aria-label="Brush" title="Brush">
            🖌️
            <input type="radio" name="tool" value="brush" onchange="onToolChange(event)" checked />
          </label>

          <label aria-label="Fill" title="Fill">
            🎆
            <input type="radio" name="tool" value="fill" onchange="onToolChange(event)" />
          </label>

          <label aria-label="Unfill" title="Unfill">
            🧼
            <input type="radio" name="tool" value="unfill" onchange="onToolChange(event)" />
          </label>
        </div>

        <div class="collapsible">
          <label id="toggle-guidelines" aria-label="Toggle Guidelines" title="Toggle Guidelines">
            📏
            <input type="checkbox" onchange="toggleGuidelines(event)" />
          </label>

          <button type="button" aria-label="Reset Size and Position" title="Reset Size and Position" onclick="resetSizeAndPosition()">🎯</button>

          <label>
            Canvas Scale
            <input type="range" id="canvasScale" name="canvasScale" min="25" max="200" value="50" step="5"
                oninput="onCanvasScaleValueChange(event.currentTarget.value, 'canvasScaleValue')" />
            <span id="canvasScaleValue">50%</span>
          </label>

          <button id="shareButton" type="button" aria-label="Share Image" title="Share Image" onclick="share()">💬</button>

          <button id="downloadButton" type="button" aria-label="Download Image" title="Download Image" onclick="download()">📥</button>
        </div>

        <div>
          <button type="button" aria-label="Reset Canvas" title="Reset Canvas" onclick="resetCanvas()">⬜</button>

          <button id="undoButton" type="button" aria-label="Undo" title="Undo" onclick="undo()" disabled>↩️</button>

          <button id="redoButton" type="button" aria-label="Redo" title="Redo" onclick="redo()" disabled>↪️</button>
        </div>
      </div>

      <label id="toggle-collapse" aria-label="Toggle Toolbar Collapse" title="Toggle Toolbar Collapse">
        <input type="checkbox" onchange="toggleMenuCollapse(event)" />
      </label>
    </div>

    <div id="brush-menu" class="submenu collapsible">
      <div>
        <label>
          Brush Size
          <input type="range" name="brushSize" min="5" max="100" value="15" step="1"
              oninput="onRangeValueChange(event, 'brushSizeValue', false)" />
          <span id="brushSizeValue">15</span>
        </label>

        <label>
          Smoothing
          <input type="range" name="smoothing" min="0" max="1" value="0.25" step="0.05"
              oninput="onRangeValueChange(event, 'smoothingValue')" />
          <span id="smoothingValue">25%</span>
        </label>
      </div>

      <div>
        <button type="button" aria-label="Generate Ellipses Pattern" title="Generate Ellipses Pattern" onclick="generateEllipsesPattern()">⚫</button>

        <button type="button" aria-label="Generate Rectangles Pattern" title="Generate Rectangles Pattern" onclick="generateRectanglesPattern()">⬛</button>

        <button type="button" aria-label="Generate Diamonds Pattern" title="Generate Diamonds Pattern" onclick="generateDiamondsPattern()">🔷</button>
      </div>

      <div>
        <button type="button" aria-label="Add Heart Rose Template" title="Add Heart Rose Template" onclick="loadTemplate('heart-rose.png')">🌹</button>

        <!-- <button type="button" aria-label="Add Christmas Tree Template" title="Add Christmas Tree Template" onclick="loadTemplate('christmas-tree.png')">🎄</button>

        <button type="button" aria-label="Add Gears Template" title="Add Gears Template" onclick="loadTemplate('gears.jpg')">⚙️</button> -->

        <button type="button" aria-label="Add Palm Tree Template" title="Add Palm Tree Template" onclick="loadTemplate('palm-tree.png')">🌴</button>
      </div>
    </div>

    <div id="fill-menu" class="submenu collapsible hidden">
      <label aria-label="Color for Fill" title="Color for Fill">
        <span style="visibility: hidden";>🎨</span>
        <input type="color" name="fillColor" oninput="onFillColorChange(event)" />
      </label>

      <div>
        <label>
          Hue Variance
          <input type="range" name="hueMutation" min="0" max="1" step="0.01" value="0.5"
              oninput="onRangeValueChange(event, 'hueMutationValue')" />
          <span id="hueMutationValue">50%</span>
        </label>

        <label>
          Saturation Variance
          <input type="range" name="saturationMutation" min="0" max="1" step="0.01" value="0.1"
              oninput="onRangeValueChange(event, 'saturationMutationValue')" />
          <span id="saturationMutationValue">10%</span>
        </label>

        <label>
          Lightness Variance
          <input type="range" name="valueMutation" min="0" max="1" step="0.01" value="0.5"
              oninput="onRangeValueChange(event, 'lightnessMutationValue')" />
          <span id="lightnessMutationValue">50%</span>
        </label>
      </div>
    </div>
  </form>

  <div
    id="contentWrapper"
    onmousedown="onCanvasMouseDown(event)"
    ontouchstart="onCanvasTouchStart(event)"
    onmouseup="onCanvasMouseUp(event)"
    ontouchend="onCanvasTouchEnd(event)"
    ontouchcancel="onCanvasTouchEnd(event)"
    onmouseenter="onCanvasMouseEnter(event)"
    onmouseleave="onCanvasMouseLeave(event)"
    ontouchmove="onCanvasTouchMove(event)"
    onwheel="onCanvasScroll(event)"
    oncontextmenu="onContextMenu(event)"
  >
    <div class="guide vertical center hidden"></div>
    <div class="guide horizontal center hidden"></div>
    <div class="guide vertical cursor hidden"></div>
    <div class="guide horizontal cursor hidden"></div>

    <div id="canvasWrapper"></div>
  </div>
</body>
</html>
