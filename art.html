<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="description" content="Make images/wallpapers with this unique web app that utilizes special color bloom effects." />

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Port+Lligat+Sans&display=swap" rel="stylesheet">

<link rel="stylesheet" type="text/css" href="./styles.css">

<title>Color Bloom Art Maker</title>

<script>
"use strict"

/* TODO:
 * - Add color selection for brush?
 * - Support stored fill presets?
 * - Support custom canvas sizes?
 * - Support uploading own images as templates?
 * - Support width varying by speed of strokes or pressure of touch/stylus?
 * - Consider using pointer events instead of separate mouse and touch events?  Not worth it except for getting pressure values.
 */

let CANVAS_WIDTH = 1920;
let CANVAS_HEIGHT = 1200;
const DELAY_THRESHOLD = 1000;
let STARTING_SATURATION = 1;
let SATURATION_MUTATION = 0;

// Only applies if using HSL
const MIN_LIGHTNESS = 0.0;
const MAX_LIGHTNESS = 0.6;

let LIGHTNESS_MUTATION;
let STARTING_LIGHTNESS;

const HISTORY_LIMIT = 1 + 10;
const BRUSH_STROKE_REPEATS = 50;
let brushStrokeCounter = 1;
let combinedHistory = [];
let combinedHistoryIndex = 0;
let fillImageDataHistory = [];
let fillPixelGridHistory = [];
let brushPixelGridHistory = [];
let fillCanvasHistory = [];
let brushCanvasHistory = [];
let fillHistoryIndex = 0;
let brushHistoryIndex = 0;
let blooms = new Map();
let growthActive = false;
let erasingOutlineForMousePress;
let interactive = true;
let isDrawing = false;
let isFilling = false;
let allBrushstrokePoints = [];
let previousBrushstrokePoints = [];
let brushPixelsChanged = false;
let fillPixelsChanged = false;
let canvasMoveScheduled = false;
let storedMovementX = 0;
let storedMovementY = 0;
let storedScaleValue = NaN;
let clickTimeoutId;
const touches = new Map();
let startingTouchDistance = NaN;
let startingScaleValue = NaN;

let HUE_MUTATION;

function generateStartingHue() {
  return Math.random() * 360;
}

function getStartingColor() {
  return rgb2hsl(...hex2rgb(getToolbarData().fillColor));
}

let STARTING_HUE = generateStartingHue();

function hex2rgb(hex) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return [r, g, b];
}

function rgb2hsl(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;

  // Find min and max values
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);

  let h, s, l = (max + min) / 2;

  if (max === min) {
    // Achromatic
    h = s = 0;
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }

  return {
    h: Math.round(h * 360),
    s,
    l,
  };
}

function hsl2rgb(h, s, l) {
  h = h / 360;

  let r, g, b;

  if (s === 0) {
    // Achromatic, set to the lightness value (this is l, not 1)
    r = g = b = l;
  } else {
    // Helper function to convert hue to RGB
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };

    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;

    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255)
  };
}

function blendHslWithAlpha(baseColor, overlayColor) {
  // Convert HSL to RGB for both colors
  const baseRGB = hsl2rgb(baseColor.h, baseColor.s, baseColor.l);
  const overlayRGB = hsl2rgb(overlayColor.h, overlayColor.s, overlayColor.l);

  const blendChannel = (base, overlay, alpha) => {
    return Math.round(base * (1 - alpha) + overlay * alpha);
  };

  // Apply alpha blending in RGB space
  const resultRGB = {
    r: blendChannel(baseRGB.r, overlayRGB.r, overlayColor.a),
    g: blendChannel(baseRGB.g, overlayRGB.g, overlayColor.a),
    b: blendChannel(baseRGB.b, overlayRGB.b, overlayColor.a)
  };

  // Convert the result back to HSL
  return rgb2hsl(resultRGB.r, resultRGB.g, resultRGB.b);
}

function randIndex(arr, forSplice = false) {
  return Math.floor(Math.random() * (arr.length + (forSplice ? 1 : 0)));
}

function randEl(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

/* function removeEl(arr, el) {
  return arr.splice(arr.indexOf(el), 1)[0];
}

function pluckRandEl(arr) {
  return removeEl(arr, randEl(arr));
} */

function getToolbarData() {
  const form = document.getElementById("toolbar");
  const data = new FormData(form);
  return Object.fromEntries(data);
}

function step() {
  return new Promise(resolve => {
    // requestAnimationFrame(resolve);
    setTimeout(resolve);
  });
}

function getColorString(h, s, l, a = 1) {
  const colorString = `hsla(${h}, ${Math.round(s * 100)}%, ${Math.round(l * 100)}%, ${a})`;
  return colorString;
}

/* function drawPixel(pixel, canvas) {
  const context = canvas.getContext("2d");
  context.shadowBlur = 0;
  context.fillStyle = getColorString(pixel.h, pixel.s, pixel.l, pixel?.a ?? 1);
  context.fillRect(pixel.x, pixel.y, 1, 1);
} */

function addFillPixel(x, y, h, s, l, startingPixel = undefined) {
  const fillPixelGrid = getFillPixelGrid();
  const existingPixel = fillPixelGrid[x][y];
  let pixelToDraw = {x, y, h, s, l};

  if (existingPixel) {
    pixelToDraw = {...pixelToDraw, ...blendHslWithAlpha(pixelToDraw, existingPixel)};
  }

  // The pixel grid data needs to reflect the original color so that branches stemming from it won't be diluted.
  // Allow brushstroke to be distinguished for erase TODO - unnecessary now?
  const pixel = {x, y, h, s, l: Math.max(l, 0.01), a: 1};
  fillPixelGrid[x][y] = pixel;
  fillPixelsChanged = true;
  // drawPixel(pixelToDraw, getFillCanvas());

  const fillImageData = getFillImageData();
  assignImageDataPixel(fillImageData, pixelToDraw);

  if (!countsAsOutlineAt(x, y)) {
    if (blooms.has(startingPixel)) {
      const branches = blooms.get(startingPixel);
      branches.splice(randIndex(branches, true), 0, pixel);
      blooms.set(startingPixel, branches);
    } else {
      blooms.set(pixel, [pixel]);
    }
  }
}

function erasePixel(x, y, erasingOutline, startingPixel = undefined) {
  const fillPixelGrid = getFillPixelGrid();
  // const fillCanvas = getFillCanvas();
  // const fillCanvasContext = fillCanvas.getContext("2d");

  if (erasingOutline) {
    const brushPixelGrid = getBrushPixelGrid();
    const a = brushPixelGrid[x][y]?.a ?? 1;
    brushPixelGrid[x][y] = undefined;
    brushPixelsChanged = true;

    const brushCanvas = getBrushCanvas();
    const brushCanvasContext = brushCanvas.getContext("2d");
    brushCanvasContext.clearRect(x, y, 1, 1);

    const fillPixel = fillPixelGrid[x][y];

    if (fillPixel) {
      // fillCanvasContext.clearRect(x, y, 1, 1);

      // if (a === 1) {
      //   fillPixelGrid[x][y] = undefined;
      // } else {
        fillPixel.a *= (1 - a);
        fillPixelGrid[x][y] = fillPixel;
        // drawPixel(fillPixel, fillCanvas);
      // }

      const fillImageData = getFillImageData();
      assignImageDataPixel(fillImageData, fillPixel);

      fillPixelsChanged = true;
    }
  } else {
    fillPixelGrid[x][y] = undefined;
    // fillCanvasContext.clearRect(x, y, 1, 1);
    const fillImageData = getFillImageData();
    assignImageDataPixel(fillImageData, {x, y, h: 0, s: 0, l: 0, a: 0});
    fillPixelsChanged = true;
  }

  if (erasingOutline || !countsAsOutlineAt(x, y)) {
    const pixel = {x, y};

    if (blooms.has(startingPixel)) {
      const branches = blooms.get(startingPixel);
      branches.splice(randIndex(branches, true), 0, pixel);
      blooms.set(startingPixel, branches);
    } else {
      blooms.set(pixel, [pixel]);
    }
  }
}

function addBrushstroke(x, y) {
  const brushSize = getToolbarData().brushSize - 2;
  const canvas = getBrushCanvas();

  const context = canvas.getContext("2d");
  context.strokeStyle = "black";
  context.lineWidth = brushSize - 2;
  context.lineCap = "round";
  context.lineJoin = "round";
  context.shadowColor = context.strokeStyle;
  context.shadowBlur = 2;

  if (previousBrushstrokePoints.length) {
    context.beginPath();
    context.moveTo(previousBrushstrokePoints[previousBrushstrokePoints.length - 1].x,
        previousBrushstrokePoints[previousBrushstrokePoints.length - 1].y);

    for (let i = previousBrushstrokePoints.length - 2; i >= 0; i--) {
      context.lineTo(previousBrushstrokePoints[i].x, previousBrushstrokePoints[i].y);
    }

    context.stroke();
  } else {
    context.beginPath();
    context.moveTo(x, y);

    // iOS Safari won't render a line with a single point, so add a tiny offset
    context.lineTo(x + 0.01, y);
    context.stroke();
  }

  previousBrushstrokePoints.unshift({x, y});

  if (previousBrushstrokePoints.length > BRUSH_STROKE_REPEATS) {
    previousBrushstrokePoints.pop();
  }

  const distance = (x - allBrushstrokePoints[allBrushstrokePoints.length - 1]?.x) ** 2
      + (y - allBrushstrokePoints[allBrushstrokePoints.length - 1]?.y) ** 2;

  if (allBrushstrokePoints.length === 0) {
    allBrushstrokePoints.push({x, y});
    brushStrokeCounter = 1;
  } else {
    if (distance > getSmoothingSquaredDistance() || brushStrokeCounter % Math.ceil(getSmoothingSquaredDistance() * 0.005 + 1) === 0) {
      brushStrokeCounter = 1;
      allBrushstrokePoints.push({x, y});
    } else {
      brushStrokeCounter++;
    }
  }
}

function getSmoothingSquaredDistance() {
  return getToolbarData().smoothing ** 3 * 50000;
}

function mutateHue(h) {
  let actualMutation = HUE_MUTATION * 7.5;

  if (h >= 23 && h <= 27) {
    // Not enough orange
    actualMutation *= 0.5;
  } else if (h >= 100 && h <= 120) {
    // Too much green
    actualMutation *= 2;
  } else if (h >= 192 && h <= 198) {
    // Not enough light blue
    actualMutation *= 0.5;
  } else if (h >= 265 && h <= 275) {
    // Not enough purple
    if (h >= 269 && h <= 271) {
      actualMutation *= 0.25;
    } else {
      actualMutation *= 0.5;
    }
  }

  return (Math.random() * actualMutation * 2 - actualMutation + h + 360) % 360;
}

function mutateSaturation(s) {
  const actualMutation = SATURATION_MUTATION * 0.05;
  return Math.max(Math.min((Math.random() * (actualMutation * 2)) - actualMutation + s, 1), 0);
}

function mutateLightness(l, s) {
  const actualMutation = LIGHTNESS_MUTATION * 0.05;
  const newValue = (Math.random() * (actualMutation * 2)) - actualMutation + l;

  // Use max lightness value when starting lightness is 0.5 and saturation is 1,
  // and let max lightness go to 1 as these values go to 0/1 and 0 respectively
  const effectiveMaxLightness = 1 - ((1 - MAX_LIGHTNESS) * s * (1 - (2 * Math.abs(0.5 - STARTING_LIGHTNESS))));
  return Math.max(Math.min(newValue, effectiveMaxLightness), MIN_LIGHTNESS);
}

function growBranch(erase = false, erasingOutline = false) {
  const [startingPixel, randBranch] = randEl([...blooms.entries()]);
  const randBranchPixel = randBranch.shift();
  const sizeLimit = parseInt(erase ? getToolbarData().eraseSize : getToolbarData().fillSize) / 2;

  const neighbors = [
    {x: randBranchPixel.x - 1, y: randBranchPixel.y},
    {x: randBranchPixel.x + 1, y: randBranchPixel.y},
    {x: randBranchPixel.x, y: randBranchPixel.y - 1},
    {x: randBranchPixel.x, y: randBranchPixel.y + 1},
  ];

  for (const neighbor of neighbors) {
    if (neighbor.x >= 0 && neighbor.x < CANVAS_WIDTH
        && neighbor.y >= 0 && neighbor.y < CANVAS_HEIGHT) {

      if (!isNaN(sizeLimit)
          && ((neighbor.x - startingPixel.x) ** 2 + (neighbor.y - startingPixel.y) ** 2) > sizeLimit ** 2) {
        // This gives perfect circles (with pixelated edges)
        // continue;

        // This gives more naturalistic splotches
        blooms.delete(startingPixel);
        return;
      }

      if (!erase) {
        if (!(getFillPixelGrid()[neighbor.x][neighbor.y]?.a === 1) && !countsAsOutlineAt(neighbor.x, neighbor.y)) {
          addFillPixel(
            neighbor.x,
            neighbor.y,
            mutateHue(randBranchPixel.h),
            mutateSaturation(randBranchPixel.s),
            mutateLightness(randBranchPixel.l, randBranchPixel.s),
            startingPixel,
          );
        }
      } else {
        if ((erasingOutline && getBrushPixelGrid()[neighbor.x][neighbor.y])
            || (!erasingOutline && getFillPixelGrid()[neighbor.x][neighbor.y])) {
          erasePixel(neighbor.x, neighbor.y, erasingOutline, startingPixel);
        }
      }
    }
  };

  if (!blooms.get(startingPixel).length) {
    blooms.delete(startingPixel);
  }
}

function countsAsOutlineAt(x, y) {
  const pixelGrid = getBrushPixelGrid();

  if (!pixelGrid[x]?.[y]) {
    return false;
  }

  if ((pixelGrid[x][y]?.a ?? 1) > 0.985) {
    return true;
  }

  return false;

  // if (pixelGrid[x][y].a < 0.5) {
  //   return false;
  // }

  // // If alpha is at least 0.5, then it's an outline if all neighbors are at least 0.5
  // const neighbors = [
  //   {x: x - 1, y: y},
  //   {x: x + 1, y: y},
  //   {x: x, y: y - 1},
  //   {x: x, y: y + 1},
  // ];

  // return neighbors.every(neighbor => !pixelGrid[neighbor.x]?.[neighbor.y] || pixelGrid[neighbor.x]?.[neighbor.y]?.a >= 0.5);
}

function addStartingPixel(x, y) {
  addFillPixel(x, y, STARTING_HUE, STARTING_SATURATION, STARTING_LIGHTNESS);
}

async function grow(x, y, erase = false, erasingOutline = false) {
  if (!growthActive) {
    brushPixelsChanged = false;
    fillPixelsChanged = false;

    if (!erase) {
      addStartingPixel(x, y);
    } else {
      erasePixel(x, y, erasingOutline);
    }

    growthActive = true;
    let growths = 1;

    while (blooms.size) {
      growBranch(erase, erasingOutline);

      if (growths % (DELAY_THRESHOLD * 1) === 0) {
        drawFillImageData();
      }

      if (growths % DELAY_THRESHOLD === 0) {
        await step();
      }

      growths++;
    }

    stopGrowth();
  } else {
    addStartingPixel(x, y);
  }
}

function getFillCanvas() {
  return fillCanvasHistory[fillHistoryIndex];
}

function getBrushCanvas() {
  return brushCanvasHistory[brushHistoryIndex];
}

function getFillImageData() {
  return fillImageDataHistory[fillHistoryIndex];
}

function getFillPixelGrid() {
  return fillPixelGridHistory[fillHistoryIndex];
}

function getBrushPixelGrid() {
  return brushPixelGridHistory[brushHistoryIndex];
}

function setNewFillPixelGrid() {
  fillPixelGridHistory[fillHistoryIndex] = Array.from({length: CANVAS_WIDTH}, () => Array.from({length: CANVAS_HEIGHT}));
}

function setNewBrushPixelGrid() {
  brushPixelGridHistory[brushHistoryIndex] = Array.from({length: CANVAS_WIDTH}, () => Array.from({length: CANVAS_HEIGHT}));
}

function storeFillCanvas() {
  const canvas = getFillCanvas();
  const canvasCopy = document.createElement("canvas");
  canvasCopy.classList.add("fill-canvas");
  canvasCopy.width = canvas.width;
  canvasCopy.height = canvas.height;
  const ctx = canvasCopy.getContext("2d", {willReadFrequently: true});
  ctx.drawImage(canvas, 0, 0);

  fillImageDataHistory.unshift(ctx.getImageData(0, 0, canvas.width, canvas.height));
  fillCanvasHistory.unshift(canvasCopy);
  document.getElementById("canvasWrapper").appendChild(canvasCopy);
  canvas.style.display = "none";
}

function storeBrushCanvas() {
  const canvas = getBrushCanvas();
  const canvasCopy = document.createElement("canvas");
  canvasCopy.classList.add("brush-canvas");
  canvasCopy.width = canvas.width;
  canvasCopy.height = canvas.height;
  const ctx = canvasCopy.getContext("2d");
  ctx.drawImage(canvas, 0, 0);

  brushCanvasHistory.unshift(canvasCopy);
  document.getElementById("canvasWrapper").appendChild(canvasCopy);
  canvas.style.display = "none";
}

function storeFillHistory() {
  // Remove all redos
  if (fillHistoryIndex > 0) {
    fillPixelGridHistory.splice(0, fillHistoryIndex);
    fillImageDataHistory.splice(0, fillHistoryIndex);
    const canvases = fillCanvasHistory.splice(0, fillHistoryIndex);
    fillHistoryIndex = 0;

    for (const canvas of canvases) {
      canvas.remove();
    }
  }

  // Store a copy of the 2D array and canvas
  fillPixelGridHistory.unshift(getFillPixelGrid().map(col => [...col]));
  storeFillCanvas();

  /* if (fillPixelGridHistory.length > HISTORY_LIMIT) {
    fillPixelGridHistory.pop();
    fillImageDataHistory.pop();
  }

  if (fillCanvasHistory.length > HISTORY_LIMIT) {
    const canvas = fillCanvasHistory.pop();
    canvas.remove();
  } */
}

function storeBrushHistory() {
  // Remove all redos
  if (brushHistoryIndex > 0) {
    brushPixelGridHistory.splice(0, brushHistoryIndex);
    const canvases = brushCanvasHistory.splice(0, brushHistoryIndex);
    brushHistoryIndex = 0;

    for (const canvas of canvases) {
      canvas.remove();
    }
  }

  // Store a copy of the 2D array and canvas
  brushPixelGridHistory.unshift(getBrushPixelGrid().map(col => [...col]));
  storeBrushCanvas();

  /* if (brushPixelGridHistory.length > HISTORY_LIMIT) {
    brushPixelGridHistory.pop();
  }

  if (brushCanvasHistory.length > HISTORY_LIMIT) {
    const canvas = brushCanvasHistory.pop();
    canvas.remove();
  } */
}

function storeCombinedHistory(historyType) {
  // Remove all redos
  if (combinedHistoryIndex > 0) {
    combinedHistory.splice(0, combinedHistoryIndex);
    combinedHistoryIndex = 0;
  }

  combinedHistory.unshift(historyType);

  if (combinedHistory.length > HISTORY_LIMIT) {
    combinedHistory.pop();
  }

  if (fillPixelGridHistory.length > HISTORY_LIMIT) {
    fillPixelGridHistory.pop();
    fillImageDataHistory.pop();
    const fillCanvas = fillCanvasHistory.pop();
    fillCanvas.remove();
  }

  if (brushPixelGridHistory.length > HISTORY_LIMIT) {
    brushPixelGridHistory.pop();
    const brushCanvas = brushCanvasHistory.pop();
    brushCanvas.remove();
  }

  // console.log(combinedHistoryIndex, combinedHistory);
  updateHistoryButtons();
}

// eslint-disable-next-line no-unused-vars
async function share() {
  if (!interactive) {
    return;
  }

  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;

  const ctx = canvas.getContext('2d');
  ctx.drawImage(getFillCanvas(), 0, 0, canvas.width, canvas.height);
  ctx.drawImage(getBrushCanvas(), 0, 0, canvas.width, canvas.height);

  const blob = await new Promise(resolve => {
    canvas.toBlob(resolve, 'image/webp');
  });

  const file = new File([blob], 'color-bloom-wallpaper.webp', { type: 'image/webp' });

  const shareData = {
    title: 'Color Bloom',
    text: 'I made some special art!',
    files: [file],
    url: '/art.html',
  };

  await navigator.share(shareData);

  canvas.remove();
}

// eslint-disable-next-line no-unused-vars
function download() {
  if (!interactive) {
    return;
  }

  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;

  const ctx = canvas.getContext('2d');
  ctx.drawImage(getFillCanvas(), 0, 0, canvas.width, canvas.height);
  ctx.drawImage(getBrushCanvas(), 0, 0, canvas.width, canvas.height);

  const link = document.createElement('a');
  link.download = 'color-bloom-wallpaper';
  link.href = canvas.toDataURL(`image/webp`);
  link.click();
  link.remove();

  canvas.remove();
}

// eslint-disable-next-line no-unused-vars
function undo() {
  if (!interactive) {
    return;
  }

  const historyType = combinedHistory[combinedHistoryIndex]

  if (historyType === "fill" || historyType === "both") {
    undoFill();
  }

  if (historyType === "brush" || historyType === "both") {
    undoBrush();
  }

  combinedHistoryIndex++;
  updateHistoryButtons();
}

function undoFill(allowRedo = true) {
  if (fillPixelGridHistory.length - 1 > fillHistoryIndex) {
    stopGrowth();

    if (allowRedo) {
      getFillCanvas().style.display = "none";
      fillHistoryIndex++;
    } else /* if (fillPixelGridHistory.length > 1) */ {
      getFillCanvas().remove();
      fillPixelGridHistory.splice(fillHistoryIndex, 1);
      fillImageDataHistory.splice(fillHistoryIndex, 1);
      fillCanvasHistory.splice(fillHistoryIndex, 1);

      if (combinedHistory[combinedHistoryIndex] === "fill") {
        combinedHistory.splice(combinedHistoryIndex, 1);
      } else if (combinedHistory[combinedHistoryIndex] === "both") {
        combinedHistory[combinedHistoryIndex] = "brush";
      }

      updateHistoryButtons();
    }

    getFillCanvas().style.display = null
  }
}

function undoBrush(allowRedo = true) {
  if (brushPixelGridHistory.length - 1 > brushHistoryIndex) {
    stopGrowth();

    if (allowRedo) {
      getBrushCanvas().style.display = "none";
      brushHistoryIndex++;
    } else /* if (brushPixelGridHistory.length > 1) */ {
      getBrushCanvas().remove();
      brushPixelGridHistory.splice(brushHistoryIndex, 1);
      brushCanvasHistory.splice(brushHistoryIndex, 1);

      if (combinedHistory[combinedHistoryIndex] === "brush") {
        combinedHistory.splice(combinedHistoryIndex, 1);
      } else if (combinedHistory[combinedHistoryIndex] === "both") {
        combinedHistory[combinedHistoryIndex] = "fill";
      }

      updateHistoryButtons();
    }

    getBrushCanvas().style.display = null;
  }
}

// eslint-disable-next-line no-unused-vars
function redo() {
  if (!interactive) {
    return;
  }

  /* const toolbarData = getToolbarData();
  const selectedTool = toolbarData.tool;

  if (selectedTool === "brush") {
    redoBrush();
  } else {
    redoFill();
  } */

  if (combinedHistoryIndex > 0) {
    combinedHistoryIndex--;
    const historyType = combinedHistory[combinedHistoryIndex];

    if (historyType === "fill" || historyType === "both") {
      redoFill();
    }

    if (historyType === "brush" || historyType === "both") {
      redoBrush();
    }

    updateHistoryButtons();
  }
}

function redoFill() {
  if (fillHistoryIndex > 0) {
    stopGrowth();
    getFillCanvas().style.display = "none";
    fillHistoryIndex--;
    getFillCanvas().style.display = null;
    // updateHistoryButtons();
  }
}

function redoBrush() {
  if (brushHistoryIndex > 0) {
    stopGrowth();
    getBrushCanvas().style.display = "none";
    brushHistoryIndex--;
    getBrushCanvas().style.display = null;
    // updateHistoryButtons();
  }
}

function updateHistoryButtons() {
  /* const toolbarData = getToolbarData();
  const selectedTool = toolbarData.tool;

  let historyIndex = fillHistoryIndex;
  let pixelGridHistory = fillPixelGridHistory;

  if (selectedTool === "brush") {
    historyIndex = brushHistoryIndex;
    pixelGridHistory = brushPixelGridHistory;
  }

  document.getElementById("undoButton").disabled = historyIndex >= pixelGridHistory.length - 1;
  document.getElementById("redoButton").disabled = historyIndex <= 0; */

  document.getElementById("undoButton").disabled = combinedHistoryIndex >= combinedHistory.length - 1;
  document.getElementById("redoButton").disabled = combinedHistoryIndex <= 0;
}

/* async function syncCanvasToPixelGrid() {
  const canvas = getFillCanvas();
  const context = canvas.getContext("2d");
  context.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

  let counter = 1;

  for (let x = 0; x < CANVAS_WIDTH; x++) {
    for (let y = 0; y < CANVAS_HEIGHT; y++) {
      const pixel = getFillPixelGrid()[x][y];

      if (pixel) {
        context.fillStyle = `hsl(${pixel.h}, ${pixel.s * 100}%, ${pixel.l * 100}%)`;
        context.fillRect(x, y, 1, 1);

        if (counter % DELAY_THRESHOLD === 0) {
          await step();
        }

        counter++;
      }
    }
  }
} */

function getImageDataIndex(x, y, canvasWidth) {
  return (y * canvasWidth + x) * 4;
}

function assignImageDataPixel(imageData, hslPixel) {
  const index = getImageDataIndex(hslPixel.x, hslPixel.y, imageData.width);
  const {r, g, b} = hsl2rgb(hslPixel.h, hslPixel.s, hslPixel.l);

  imageData.data[index] = r;
  imageData.data[index + 1] = g;
  imageData.data[index + 2] = b;
  imageData.data[index + 3] = (hslPixel.a ?? 1) * 255;
}

function drawFillImageData() {
  const imageData = getFillImageData();
  const canvas = getFillCanvas();
  const context = canvas.getContext("2d");
  context.putImageData(imageData, 0, 0);
}

async function syncPixelGridToBrushCanvas() {
  const canvas = getBrushCanvas();
  const context = canvas.getContext("2d", {willReadFrequently: true});
  context.shadowBlur = 0;
  const previousPixelGrid = brushPixelGridHistory[brushHistoryIndex + 1];
  const {data} = context.getImageData(0, 0, canvas.width, canvas.height);

  brushPixelGridHistory[brushHistoryIndex] = Array.from({length: CANVAS_WIDTH},
      (_elX, x) => Array.from({length: CANVAS_HEIGHT}, (_elY, y) => {
    const index = (y * CANVAS_WIDTH + x) * 4;
    // TODO - support other colors?
    // const r = data[index];
    // const g = data[index + 1];
    // const b = data[index + 2];
    const a = data[index + 3] / 255;

    // let {h, s, l} = rgb2hsl(r, g, b);

    // if (a > 0.2 && l < 0.5) {
    //   const pixel = {x: i, y: j, h: 0, s: 0, l: 0};
    //   pixelGrid[i][j] = pixel;
    //   drawPixel(pixel, getBrushCanvas());
    // }

    const pixel = a > 0 ? {x, y, h: 0, s: 0, l: 0, a} : undefined;

    // TODO - support other colors?
    if (previousPixelGrid[x][y] && !pixel || pixel && !previousPixelGrid[x][y]
        || pixel?.a !== previousPixelGrid[x][y]?.a) {
      brushPixelsChanged = true;
    }

    return pixel;
  }));
}

// eslint-disable-next-line no-unused-vars
function resetCanvas() {
  if (!interactive) {
    return;
  }

  stopGrowth();

  let historyType = "";

  if (getFillPixelGrid().flat().some(pixel => pixel)) {
    storeFillHistory();
    setNewFillPixelGrid();
    const fillCanvas = getFillCanvas();
    const fillContext = fillCanvas.getContext("2d", {willReadFrequently: true});
    fillContext.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    fillImageDataHistory.unshift(fillContext.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT));
    historyType = "fill";
  }

  if (getBrushPixelGrid().flat().some(pixel => pixel)) {
    storeBrushHistory();
    setNewBrushPixelGrid();
    getBrushCanvas().getContext("2d").clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    historyType = historyType === "fill" ? "both" : "brush";
  }

  if (historyType) {
    storeCombinedHistory(historyType);
  }
}

function setCssVar(name, value) {
  document.documentElement.style.setProperty(name, value);
}

function getCssVar(name) {
  return getComputedStyle(document.documentElement).getPropertyValue(name);
}

function onFillColorChange(event) {
  setCssVar('--selected-fill-color', event.currentTarget.value);
}

function onRangeValueChange(event, spanId, displayAsPercent = true) {
  document.getElementById(spanId).innerText = displayAsPercent ?
      `${Math.floor(event.currentTarget.value * 100 / event.currentTarget.max)}%` : event.currentTarget.value;
}

function onCanvasScaleValueChange(value, spanId) {
  document.getElementById(spanId).innerText = `${value}%`;
  setCssVar('--canvas-scale', value / 100);
}

function getCanvasCoordinates(mouseX, mouseY) {
  const canvas = getFillCanvas();
  const scale = getCssVar('--canvas-scale');

  let {x, y} = canvas.getBoundingClientRect();
  x = Math.round((mouseX - x) / scale);
  y = Math.round((mouseY - y) / scale);

  return {x, y};
}

function convertToMouseCoordinates(canvasX, canvasY) {
  const canvas = getFillCanvas();
  const scale = getCssVar('--canvas-scale');

  const {x, y} = canvas.getBoundingClientRect();
  return {x: x + canvasX * scale, y: y + canvasY * scale};
}

function handleClick(clickX, clickY, fromMove = false) {
  let {x, y} = getCanvasCoordinates(clickX, clickY);

  if (x >= 0 && x < CANVAS_WIDTH
      && y >= 0 && y < CANVAS_HEIGHT) {
    const toolbarData = getToolbarData();
    const selectedTool = toolbarData.tool;

    if (selectedTool === "fill") {
      if (!getFillPixelGrid()[x][y]?.a && !countsAsOutlineAt(x, y)) {
        if (!growthActive) {
          const {h, s, l} = getStartingColor();
          STARTING_HUE = h;
          STARTING_SATURATION = s;
          STARTING_LIGHTNESS = l;

          HUE_MUTATION = toolbarData.hueMutation;
          SATURATION_MUTATION = toolbarData.saturationMutation;
          LIGHTNESS_MUTATION = toolbarData.valueMutation;

          if (!fillPixelsChanged) {
            storeFillHistory();
            storeCombinedHistory("fill");
          }
        }

        grow(x, y);
      } else if (!fromMove && !isFilling && growthActive) {
        stopGrowth();
      } else if (!growthActive) {
        // Give leeway equal to have the fill size
        const fillSize = parseInt(toolbarData.fillSize) / 2;

        if (!isNaN(fillSize)) {
          const halfSize = Math.ceil(fillSize * 0.5);

          for (let i = Math.max(0, x - halfSize); i <= Math.min(CANVAS_WIDTH - 1, x + halfSize); i++) {
            for (let j = Math.max(0, y - halfSize); j <= Math.min(CANVAS_HEIGHT - 1, y + halfSize); j++) {
              // If point is not further from (x, y) than halfSize
              if (Math.pow(i - x, 2) + Math.pow(j - y, 2) <= Math.pow(halfSize, 2)) {
                if (!getFillPixelGrid()[i][j]?.a && !countsAsOutlineAt(i, j)) {
                  const {x: mouseX, y: mouseY} = convertToMouseCoordinates(i, j);
                  handleClick(mouseX, mouseY, fromMove);
                  return;
                }
              }
            }
          }
        }
      }
    } else if (selectedTool === "erase") {
      if (getFillPixelGrid()[x][y]?.a || getBrushPixelGrid()[x][y]?.a) {
        const fillingNotStarted = erasingOutlineForMousePress == null;

        if (fillingNotStarted) {
          erasingOutlineForMousePress = !!getBrushPixelGrid()[x][y];
        } else if (erasingOutlineForMousePress && !getBrushPixelGrid()[x][y]?.a) {
          return;
        }

        if (!growthActive) {
          if (fillingNotStarted || (!fillPixelsChanged && !brushPixelsChanged)) {
            if (erasingOutlineForMousePress) {
              storeBrushHistory();
            }

            storeFillHistory();
            storeCombinedHistory(erasingOutlineForMousePress ? "both" : "fill");
          }
        }

        grow(x, y, true, erasingOutlineForMousePress);
      } else if (!fromMove && !isFilling && growthActive) {
        stopGrowth();
      } else if (!growthActive) {
        // Give leeway equal to have the erase size
        const eraseSize = parseInt(toolbarData.eraseSize) / 2;

        if (!isNaN(eraseSize)) {
          const halfSize = Math.ceil(eraseSize * 0.5);

          for (let i = Math.max(0, x - halfSize); i <= Math.min(CANVAS_WIDTH - 1, x + halfSize); i++) {
            for (let j = Math.max(0, y - halfSize); j <= Math.min(CANVAS_HEIGHT - 1, y + halfSize); j++) {
              // If point is not further from (x, y) than halfSize
              if (Math.pow(i - x, 2) + Math.pow(j - y, 2) <= Math.pow(halfSize, 2)) {
                if (getFillPixelGrid()[i][j]?.a || getBrushPixelGrid()[i][j]?.a) {
                  const {x: mouseX, y: mouseY} = convertToMouseCoordinates(i, j);
                  handleClick(mouseX, mouseY, fromMove);
                  return;
                }
              }
            }
          }
        }
      }
    }
  }
}

// const FILL_BRUSH_THROTTLE = 5;
// let fillBrushCounter = FILL_BRUSH_THROTTLE - 1;

function onCanvasMouseMove(event) {
  const contentWrapper = document.getElementById("contentWrapper");

  if (!contentWrapper) {
    return;
  }

  const draggingCanvas = event.buttons !== 1 && contentWrapper.classList.contains("positioning");
  const shouldDrag = draggingCanvas && interactive;

  if (shouldDrag) {
    storedMovementX += event.movementX;
    storedMovementY += event.movementY;
  }

  if (!canvasMoveScheduled) {
    canvasMoveScheduled = true;
    const clientX = event.clientX;
    const clientY = event.clientY;

    requestAnimationFrame(() => {
      canvasMoveScheduled = false;
      setCssVar('--mouse-x', `${clientX}px`);
      setCssVar('--mouse-y', `${clientY}px`);

      if (shouldDrag) {
        const offsetLimitX = window.innerWidth * 0.6;
        const offsetLimitY = window.innerHeight * 0.6;
        setCssVar('--canvas-offset-x', `${Math.min(Math.max(parseInt(getCssVar('--canvas-offset-x')) + storedMovementX,
            -offsetLimitX), offsetLimitX)}px`);
        setCssVar('--canvas-offset-y', `${Math.min(Math.max(parseInt(getCssVar('--canvas-offset-y')) + storedMovementY,
            -offsetLimitY), offsetLimitY)}px`);

        storedMovementX = 0;
        storedMovementY = 0;
      }
    });
  }

  if (!interactive) {
    return;
  }

  // event.buttons is 1 for the primary button (left click)
  if (event.buttons === 1) {
    const selectedTool = getToolbarData().tool;

    if (isDrawing) {
      if (selectedTool === "brush") {
        let {x, y} = getCanvasCoordinates(event.x, event.y);
        addBrushstroke(x, y);
      }
    } else if (isFilling) {
      // if (growthActive) {
        // if (++fillBrushCounter % FILL_BRUSH_THROTTLE === 0) {
        //   fillBrushCounter = 0;
          clearTimeout(clickTimeoutId);
          clickTimeoutId = null;
          handleClick(event.clientX, event.clientY, true);
        // }
      // }
    }
  }
}

function onCanvasTouchMove(event) {
  event.preventDefault();

  const eventTouches = [...event.touches];

  // For testing
  // const contentWrapper = document.getElementById("contentWrapper");
  // const newTouch = new Touch({identifier: Date.now(), clientX: 100, clientY: 100, target: contentWrapper});
  // eventTouches.push(newTouch);

  const draggingCanvas = eventTouches.length > 1
      && document.getElementById("contentWrapper").classList.contains("positioning")
  const shouldDrag = draggingCanvas; // && interactive;

  let netMovementX = 0, netMovementY = 0, totalDistance = 0, pairCount = 0;

  for (const touch of eventTouches) {
    const oldTouch = touches.get(touch.identifier);

    if (oldTouch) {
      netMovementX += touch.clientX - oldTouch.clientX;
      netMovementY += touch.clientY - oldTouch.clientY;

      if (shouldDrag) {
        for (const otherTouch of eventTouches) {
          if (touch.identifier === otherTouch.identifier) {
            continue;
          }

          totalDistance += Math.hypot(otherTouch.clientX - touch.clientX, otherTouch.clientY - touch.clientY);
          pairCount++;
        }
      }
    }

    touches.set(touch.identifier, {identifier: touch.identifier, clientX: touch.clientX, clientY: touch.clientY});
  }

  if (shouldDrag) {
    if (pairCount > 1) {
      netMovementX = Math.round(netMovementX / pairCount);
      netMovementY = Math.round(netMovementY / pairCount);
    }

    const averageDistance = totalDistance / pairCount;

    if (pairCount > 0 && !isNaN(startingTouchDistance) && !isNaN(startingScaleValue)) {
      const normalizationFactor = 0.25;
      const deltaDistance = (averageDistance - startingTouchDistance) * normalizationFactor;
      // Round to the nearest 5
      storedScaleValue = Math.round((startingScaleValue + deltaDistance) * 0.2) * 5;
    }

    storedMovementX += netMovementX;
    storedMovementY += netMovementY;

    if (!canvasMoveScheduled) {
      canvasMoveScheduled = true;

      requestAnimationFrame(() => {
        canvasMoveScheduled = false;

        if (storedMovementX || storedMovementY) {
          const offsetLimitX = window.innerWidth * 0.6;
          const offsetLimitY = window.innerHeight * 0.6;
          setCssVar('--canvas-offset-x', `${Math.min(Math.max(parseInt(getCssVar('--canvas-offset-x')) + storedMovementX,
              -offsetLimitX), offsetLimitX)}px`);
          setCssVar('--canvas-offset-y', `${Math.min(Math.max(parseInt(getCssVar('--canvas-offset-y')) + storedMovementY,
              -offsetLimitY), offsetLimitY)}px`);

          storedMovementX = 0;
          storedMovementY = 0;
        }

        if (!isNaN(storedScaleValue)) {
          const scaleInput = document.getElementById('canvasScale');
          scaleInput.value = storedScaleValue;
          onCanvasScaleValueChange(scaleInput.value, 'canvasScaleValue');

          storedScaleValue = NaN;
        }
      });
    }
  }

  if (!interactive) {
    return;
  }

  if (eventTouches.length === 1) {
    const selectedTool = getToolbarData().tool;

    if (isDrawing) {
      if (selectedTool === "brush") {
        let {x, y} = getCanvasCoordinates(eventTouches[0].clientX, eventTouches[0].clientY);
        addBrushstroke(x, y);
      }
    } else if (isFilling) {
      clearTimeout(clickTimeoutId);
      clickTimeoutId = null;
      handleClick(eventTouches[0].clientX, eventTouches[0].clientY, true);
    }
  }
}

// eslint-disable-next-line no-unused-vars
function viewCanvas() {
  document.getElementById("toolbar").classList.add("hidden");
  document.getElementById("portfolio-link").classList.add("hidden");
}

function onCanvasMouseDown(event) {
  previousBrushstrokePoints = [];

  if (!interactive) {
    return;
  }

  // event.buttons is 1 for the primary button (left click)
  if (event.buttons === 1) {
    clearTimeout(clickTimeoutId);
    clickTimeoutId = setTimeout(() => {
      clearTimeout(clickTimeoutId);
      clickTimeoutId = null;
    }, 200);

    const toolbar = document.getElementById("toolbar");

    if (toolbar.classList.contains("hidden")) {
      return;
    }

    const selectedTool = getToolbarData().tool;
    const {x, y} = getCanvasCoordinates(event.x, event.y);

    if (selectedTool === "brush") {
      stopGrowth();
      storeBrushHistory();
      storeCombinedHistory("brush");
      brushPixelsChanged = false;
      isDrawing = true;
      addBrushstroke(x, y);
    } else {
      if (growthActive && !(x >= 0 && x < CANVAS_WIDTH
          && y >= 0 && y < CANVAS_HEIGHT)) {
        stopGrowth();
      } else {
        isFilling = true;
      }
    }
  } else {
    document.getElementById("contentWrapper").classList.add("positioning");
  }

  setCssVar('--toolbar-pointer-events', 'none');
}

async function finishDrawing() {
  if (isDrawing) {
    isDrawing = false;

    if (allBrushstrokePoints.length) {
      pauseInteraction();

      if (previousBrushstrokePoints.length) {
        let lastPoint = previousBrushstrokePoints[0];
        const firstPoint = allBrushstrokePoints[0];
        const distance = (lastPoint.x - firstPoint.x) ** 2 + (lastPoint.y - firstPoint.y) ** 2;

        // If distance from starting point is small, use the midpoint for both
        if (allBrushstrokePoints.length > 2 && distance < getSmoothingSquaredDistance() * 0.5) {
          const midX = Math.round((lastPoint.x + firstPoint.x) * 0.5);
          const midY = Math.round((lastPoint.y + firstPoint.y) * 0.5);
          lastPoint = {x: midX, y: midY};
          firstPoint.x = midX;
          firstPoint.y = midY;
        }

        // iOS Safari won't render a line with a single point, so add a tiny offset
        allBrushstrokePoints.push({...lastPoint, x: lastPoint.x + 0.01});
      }

      const brushSize = getToolbarData().brushSize;
      const canvas = getBrushCanvas();
      const canvasContext = canvas.getContext("2d");
      const prevCanvas = brushCanvasHistory[brushHistoryIndex + 1];

      canvasContext.strokeStyle = "black";
      canvasContext.lineWidth = brushSize;
      canvasContext.shadowBlur = 0;
      canvasContext.shadowColor = canvasContext.strokeStyle;
      canvasContext.lineCap = "round";
      canvasContext.lineJoin = "round";
      canvasContext.clearRect(0, 0, canvas.width, canvas.height);
      canvasContext.drawImage(prevCanvas, 0, 0);
      canvasContext.shadowBlur = 2;

      canvasContext.beginPath();
      canvasContext.moveTo(allBrushstrokePoints[0].x, allBrushstrokePoints[0].y);

      for (let j = 0; j < allBrushstrokePoints.length - 1; j++) {
        // Calculate control points for a smooth curve
        const xc = (allBrushstrokePoints[j].x + allBrushstrokePoints[j + 1].x) * 0.5;
        const yc = (allBrushstrokePoints[j].y + allBrushstrokePoints[j + 1].y) * 0.5;

        // // Adjust line width based on velocity (faster = thinner)
        // const maxWidth = 8;
        // const minWidth = 2;
        // let lineWidth = maxWidth - (this.points[i].velocity * 0.1);
        // lineWidth = Math.max(minWidth, Math.min(maxWidth, lineWidth));

        // canvasContext.lineWidth = lineWidth;
        canvasContext.quadraticCurveTo(allBrushstrokePoints[j].x, allBrushstrokePoints[j].y, xc, yc);
      }

      canvasContext.lineTo(allBrushstrokePoints[allBrushstrokePoints.length - 1].x, allBrushstrokePoints[allBrushstrokePoints.length - 1].y);
      canvasContext.stroke();

      await syncPixelGridToBrushCanvas();
      resumeInteraction();

      allBrushstrokePoints = [];
    }

    if (!brushPixelsChanged) {
      undoBrush(false);
    }
  }
}

function pauseInteraction() {
  interactive = false;
  const form = document.getElementById("toolbar");
  form.inert = true;
  document.body.style.cursor = "wait";
}

function resumeInteraction() {
  interactive = true;
  const form = document.getElementById("toolbar");
  form.inert = false;
  document.body.style.cursor = null;
}

function onCanvasMouseUp(event) {
  setCssVar('--toolbar-pointer-events', 'all');
  document.getElementById("contentWrapper").classList.remove("positioning");

  const toolbar = document.getElementById("toolbar");
  setTimeout(() => {
    toolbar.classList.remove("hidden");
    document.getElementById("portfolio-link").classList.remove("hidden");
  }, 50);

  // event.button is 0 for the primary button (left click)
  if (event.button === 0) {
    finishDrawing();

    if (erasingOutlineForMousePress == null) {
      // No stored fill history to undo
      isFilling = false;

      if (!growthActive) {
        fillPixelsChanged = false;
      }
    } else {
      stopFilling();
    }

    if (interactive && clickTimeoutId) {
      clearTimeout(clickTimeoutId);
      clickTimeoutId = null;

      handleClick(event.x, event.y);
    }
  }
}

function onCanvasTouchStart(event) {
  event.preventDefault();

  const eventTouches = [...event.touches];

  // For testing
  // const contentWrapper = document.getElementById("contentWrapper");
  // const newTouch = new Touch({identifier: Date.now(), clientX: 100, clientY: 100, target: contentWrapper});
  // eventTouches.push(newTouch);

  const scaleInput = document.getElementById('canvasScale');
  startingScaleValue = +scaleInput.value;

  previousBrushstrokePoints = [];

  if (eventTouches.length === 1) {
    for (const touch of eventTouches) {
      touches.set(touch.identifier, {identifier: touch.identifier, clientX: touch.clientX, clientY: touch.clientY});
    }

    if (interactive) {
      clearTimeout(clickTimeoutId);
      clickTimeoutId = setTimeout(() => {
        clearTimeout(clickTimeoutId);
        clickTimeoutId = null;
      }, 200);

      const toolbar = document.getElementById("toolbar");

      if (toolbar.classList.contains("hidden")) {
        return;
      }

      const selectedTool = getToolbarData().tool;
      const {x, y} = getCanvasCoordinates(eventTouches[0].clientX, eventTouches[0].clientY);

      if (selectedTool === "brush") {
        event.preventDefault();
        stopGrowth();
        storeBrushHistory();
        storeCombinedHistory("brush");
        brushPixelsChanged = false;
        isDrawing = true;
        addBrushstroke(x, y);
      } else {
        if (growthActive && !(x >= 0 && x < CANVAS_WIDTH
            && y >= 0 && y < CANVAS_HEIGHT)) {
          stopGrowth();
        } else {
          isFilling = true;
        }
      }
    }
  } else {
    clearTimeout(clickTimeoutId);
    clickTimeoutId = null;

    finishDrawing();

    if (!fillPixelsChanged) {
      // No stored fill history to undo
      isFilling = false;
    } else {
      stopFilling();
    }

    document.getElementById("contentWrapper").classList.add("positioning");

    let totalDistance = 0, pairCount = 0;

    for (const touch of eventTouches) {
      for (const otherTouch of eventTouches) {
        if (touch.identifier === otherTouch.identifier) {
          continue;
        }

        totalDistance += Math.hypot(otherTouch.clientX - touch.clientX, otherTouch.clientY - touch.clientY);
        pairCount++;
      }

      touches.set(touch.identifier, {identifier: touch.identifier, clientX: touch.clientX, clientY: touch.clientY});
    }

    if (pairCount > 1) {
      startingTouchDistance = totalDistance / pairCount;
    }
  }

  setCssVar('--toolbar-pointer-events', 'none');
}

function onCanvasTouchEnd(event) {
  event.preventDefault();

  for (const touch of event.changedTouches) {
    touches.delete(touch.identifier);
  }

  if (event.touches.length < 2) {
    startingTouchDistance = NaN;
    document.getElementById("contentWrapper").classList.remove("positioning");

    if (event.touches.length === 0) {
      finishDrawing();

      if (erasingOutlineForMousePress == null) {
        // No stored fill history to undo
        isFilling = false;

        if (!growthActive) {
          fillPixelsChanged = false;
        }
      } else {
        stopFilling();
      }

      setCssVar('--toolbar-pointer-events', 'all');

      const toolbar = document.getElementById("toolbar");
      setTimeout(() => {
        toolbar.classList.remove("hidden");
        document.getElementById("portfolio-link").classList.remove("hidden");
      }, 50);

      if (interactive && clickTimeoutId) {
        clearTimeout(clickTimeoutId);
        clickTimeoutId = null;

        handleClick(event.changedTouches[0].clientX, event.changedTouches[0].clientY);
      }
    }
  } else if (event.touches.length > 1) {
    let totalDistance = 0, pairCount = 0;

    for (const touch of event.touches) {
      for (const otherTouch of event.touches) {
        if (touch.identifier === otherTouch.identifier) {
          continue;
        }

        totalDistance += Math.hypot(otherTouch.clientX - touch.clientX, otherTouch.clientY - touch.clientY);
        pairCount++;
      }

      touches.set(touch.identifier, {identifier: touch.identifier, clientX: touch.clientX, clientY: touch.clientY});
    }

    if (pairCount > 0) {
      const scaleInput = document.getElementById('canvasScale');
      startingScaleValue = +scaleInput.value;
      startingTouchDistance = totalDistance / pairCount;
    }
  }
}

function onCanvasMouseEnter(event) {
  // event.buttons is 1 for the primary button (left click)
  if (!interactive || event.buttons !== 1) {
    finishDrawing();
    stopFilling();
    setCssVar('--toolbar-pointer-events', 'all');
  }

  if (!interactive || event.buttons === 1 || event.buttons === 0) {
    document.getElementById("contentWrapper").classList.remove("positioning");
  }
}

function onCanvasMouseLeave() {
  // finishBrushstrokes();

  setCssVar('--mouse-x', `${-1000}px`);
  setCssVar('--mouse-y', `${-1000}px`);
}

function onCanvasScroll(event) {
  const scaleInput = document.getElementById('canvasScale');

  if (event.deltaY > 0) {
    scaleInput.value -= scaleInput.step;
  } else {
    scaleInput.value = +scaleInput.value + +scaleInput.step;
  }

  onCanvasScaleValueChange(scaleInput.value, 'canvasScaleValue');
}

function onContextMenu(event) {
  event.preventDefault();
  finishDrawing();
  stopFilling();
}

function stopGrowth() {
  if (growthActive) {
    growthActive = false;
    blooms = new Map();

    if (!isFilling) {
      if (!fillPixelsChanged) {
        undoFill(false);
      }

      fillPixelsChanged = false;

      if (erasingOutlineForMousePress && !brushPixelsChanged) {
        undoBrush(false);
      }

      erasingOutlineForMousePress = null;
      brushPixelsChanged = false;
    }

    drawFillImageData();
  }
}

function stopFilling() {
  if (isFilling) {
    isFilling = false;

    if (!growthActive) {
      if (!fillPixelsChanged) {
        undoFill(false);
      }

      fillPixelsChanged = false;

      if (erasingOutlineForMousePress && !brushPixelsChanged) {
        undoBrush(false);
      }

      erasingOutlineForMousePress = null;
      brushPixelsChanged = false;
    }
  }
}

// eslint-disable-next-line no-unused-vars
function loadTemplate(filename) {
  if (!interactive) {
    return;
  }

  const image = new Image();
  image.crossOrigin = "anonymous";
  image.src = `images/${filename}`;
  image.onload = () => {
    imageTo2DArray(image);
  };
}

// eslint-disable-next-line no-unused-vars
function generateEllipsesPattern() {
  if (!interactive) {
    return;
  }

  stopGrowth();
  storeBrushHistory();
  storeCombinedHistory("brush");

  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;
  const ctx = canvas.getContext('2d');
  ctx.strokeStyle = 'black';
  ctx.shadowColor = ctx.strokeStyle;
  ctx.shadowBlur = 2;

  const radiusRange = Math.min(canvas.width, canvas.height) * 2;
  const minRadius = radiusRange * 0.05;
  const numCircles = 10; // Math.round(canvas.width * canvas.height / 200000);

  for (let i = 0; i < numCircles; i++) {
    const x = Math.floor(Math.random() * canvas.width * 2 - canvas.width);
    const y = Math.floor(Math.random() * canvas.height * 2 - canvas.height);
    const radiusX = Math.round(Math.random() ** 2 * radiusRange + minRadius);
    const radiusY = Math.random() < 0.5 ? radiusX : Math.round(Math.random() ** 2 * radiusRange + minRadius);
    const rotation = Math.random() * Math.PI * 2;
    const thickness = Math.floor(Math.random() * 19 + 4);

    ctx.beginPath();
    ctx.ellipse(x, y, radiusX, radiusY, rotation, 0, 2 * Math.PI);
    ctx.lineWidth = thickness;

    for (let i = 0; i < BRUSH_STROKE_REPEATS; i++) {
      ctx.stroke();
    }
  }

  const {data} = ctx.getImageData(0, 0, canvas.width, canvas.height);

  drawImageData(data);

  canvas.remove();

  updateHistoryButtons();
}

// eslint-disable-next-line no-unused-vars
function generateRectanglesPattern() {
  if (!interactive) {
    return;
  }

  stopGrowth();
  storeBrushHistory();
  storeCombinedHistory("brush");

  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;
  const ctx = canvas.getContext('2d');
  ctx.strokeStyle = 'black';
  ctx.shadowColor = ctx.strokeStyle;
  ctx.shadowBlur = 2;

  const widthRange = Math.min(canvas.width, canvas.height) * 4;
  const minWidth = widthRange * 0.05;
  const numSquares = 10; // Math.round(canvas.width * canvas.height / 200000);

  for (let i = 0; i < numSquares; i++) {
    const x = Math.floor(Math.random() * canvas.width * 2 - canvas.width);
    const y = Math.floor(Math.random() * canvas.height * 2 - canvas.height);
    const width = Math.round(Math.random() ** 2 * widthRange + minWidth);
    const height = Math.random() < 0.5 ? width : Math.round(Math.random() ** 2 * widthRange + minWidth);
    const thickness = Math.floor(Math.random() * 19 + 4);

    ctx.beginPath();
    ctx.rect(x, y, width, height);
    ctx.lineWidth = thickness;

    for (let i = 0; i < BRUSH_STROKE_REPEATS; i++) {
      ctx.stroke();
    }
  }

  const {data} = ctx.getImageData(0, 0, canvas.width, canvas.height);

  drawImageData(data);

  canvas.remove();

  updateHistoryButtons();
}

// eslint-disable-next-line no-unused-vars
function generateDiamondsPattern() {
  if (!interactive) {
    return;
  }

  stopGrowth();
  storeBrushHistory();
  storeCombinedHistory("brush");

  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;
  const ctx = canvas.getContext('2d');
  ctx.strokeStyle = 'black';
  ctx.shadowColor = ctx.strokeStyle;
  ctx.shadowBlur = 2;

  const widthRange = Math.min(canvas.width, canvas.height) * 4;
  const minWidth = widthRange * 0.05;
  const numSquares = 10; // Math.round(canvas.width * canvas.height / 200000);

  for (let i = 0; i < numSquares; i++) {
    const x = Math.floor(Math.random() * canvas.width * 2 - canvas.width);
    const y = Math.floor(Math.random() * canvas.height * 2 - canvas.height);
    const width = Math.round(Math.random() ** 2 * widthRange + minWidth);
    const height = Math.random() < 0.5 ? width : Math.round(Math.random() ** 2 * widthRange + minWidth);
    const thickness = Math.floor(Math.random() * 19 + 4);

    ctx.beginPath();
    ctx.translate(x, y);
    ctx.rotate(Math.PI * 0.25);
    ctx.translate(-x, -y);

    ctx.rect(x, y, width, height);
    ctx.lineWidth = thickness;

    for (let i = 0; i < BRUSH_STROKE_REPEATS; i++) {
      ctx.stroke();
    }

    ctx.translate(x, y);
    ctx.rotate(-Math.PI * 0.25);
    ctx.translate(-x, -y);
  }

  const {data} = ctx.getImageData(0, 0, canvas.width, canvas.height);

  drawImageData(data);

  canvas.remove();

  updateHistoryButtons();
}

// TODO
/* function generateSpiralPattern() {
  if (!interactive) {
    return;
  }

  stopGrowth();
  storeBrushHistory();
  storeCombinedHistory("brush");

  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;
  const ctx = canvas.getContext('2d');
  ctx.strokeStyle = 'black';
  ctx.shadowColor = ctx.strokeStyle;
  ctx.shadowBlur = 2;

  const widthRange = Math.min(canvas.width, canvas.height) * 4;
  const minWidth = widthRange * 0.05;
  const numSpirals = Math.floor(Math.random() * 19) + 6;

  for (let i = 0; i < numSquares; i++) {
    const x = Math.floor(Math.random() * canvas.width * 2 - canvas.width);
    const y = Math.floor(Math.random() * canvas.height * 2 - canvas.height);
    const width = Math.round(Math.random() ** 2 * widthRange + minWidth);
    const height = Math.random() < 0.5 ? width : Math.round(Math.random() ** 2 * widthRange + minWidth);
    const thickness = Math.floor(Math.random() * 19 + 4);

    ctx.beginPath();
    ctx.translate(x, y);
    ctx.rotate(Math.PI * 0.25);
    ctx.translate(-x, -y);

    ctx.rect(x, y, width, height);
    ctx.lineWidth = thickness;

    for (let i = 0; i < BRUSH_STROKE_REPEATS; i++) {
      ctx.stroke();
    }

    ctx.translate(x, y);
    ctx.rotate(-Math.PI * 0.25);
    ctx.translate(-x, -y);
  }

  const {data} = ctx.getImageData(0, 0, canvas.width, canvas.height);

  drawImageData(data);

  canvas.remove();

  updateHistoryButtons();
} */

function imageTo2DArray(image) {
  stopGrowth();
  storeBrushHistory();
  storeCombinedHistory("brush");

  fillPixelsChanged = false;
  brushPixelsChanged = false;

  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;
  const ctx = canvas.getContext('2d', {willReadFrequently: true});

  // Calculate scaling and positioning
  const imageAspectRatio = image.width / image.height;
  const canvasAspectRatio = CANVAS_WIDTH / CANVAS_HEIGHT;

  let drawWidth, drawHeight, offsetX = CANVAS_WIDTH / 10, offsetY = CANVAS_HEIGHT / 10;

  if (imageAspectRatio > canvasAspectRatio) {
    // Image is wider relative to canvas
    drawWidth = CANVAS_WIDTH * 0.8;
    drawHeight = CANVAS_WIDTH * 0.8 / imageAspectRatio;
    offsetY = (CANVAS_HEIGHT - drawHeight) / 2;
  } else {
    // Image is taller relative to canvas
    drawHeight = CANVAS_HEIGHT * 0.8;
    drawWidth = CANVAS_HEIGHT * 0.8 * imageAspectRatio;
    offsetX = (CANVAS_WIDTH - drawWidth) / 2;
  }

  ctx.drawImage(image, offsetX, offsetY, drawWidth, drawHeight);
  const {data} = ctx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

  drawImageData(data, true);

  canvas.remove();

  updateHistoryButtons();
}

function drawImageData(data, ensureOutline = false) {
  const pixelGrid = getBrushPixelGrid();
  const canvas = getBrushCanvas();
  const context = canvas.getContext("2d");
  context.shadowBlur = 0;

  for (let i = 0; i < CANVAS_WIDTH; i++) {
    for (let j = 0; j < CANVAS_HEIGHT; j++) {
      const index = (j * CANVAS_WIDTH + i) * 4;
      const r = data[index];
      const g = data[index + 1];
      const b = data[index + 2];
      let a = data[index + 3] / 255;

      let {/* h, s,  */l} = rgb2hsl(r, g, b);

      // if (a > 0.2 && l < 0.5) {
      //   const pixel = {x: i, y: j, h: 0, s: 0, l: 0};
      //   pixelGrid[i][j] = pixel;
      //   drawPixel(pixel, getBrushCanvas());
      // }

      // TODO - support other colors?
      if (a > 0 && l < 0.5) {
        if (ensureOutline && a > 0.75) {
          a = 1;
        }

        const pixel = {x: i, y: j, h: 0, s: 0, l: 0, a: Math.max(a, pixelGrid[i][j]?.a || 0)};
        pixelGrid[i][j] = pixel;

        context.fillStyle = getColorString(pixel.h, pixel.s, pixel.l, a);
        context.fillRect(pixel.x, pixel.y, 1, 1);
      }
    }
  }
}

// eslint-disable-next-line no-unused-vars
function resetScaleAndPosition() {
  const scaleInput = document.getElementById('canvasScale');
  scaleInput.value = 50;
  onCanvasScaleValueChange(scaleInput.value, 'canvasScaleValue');

  setCssVar('--canvas-offset-x', '0px');
  setCssVar('--canvas-offset-y', '50px');
}

function openOptionInfoDialog(emojiIcon, label, description) {
  const optionInfoDialog = document.getElementById('toolbar-option-info-dialog');
  const modalContent = optionInfoDialog.querySelector('.modal-content');
  modalContent.innerHTML = `
    <p><span aria-hidden="true">${emojiIcon} </span>${label}</p>
    <ul>${description.split('  ').map(line => `<li>${line}</li>`).join('')}</ul>
  `;

  optionInfoDialog.showModal();
}

// eslint-disable-next-line no-unused-vars
function closeOptionInfoDialog() {
  const optionInfoDialog = document.getElementById('toolbar-option-info-dialog');
  optionInfoDialog.close();
}

function setUserSelect(enabled) {
  const value = enabled ? null : 'none';
  document.body.style.userSelect = value;
  document.body.style.webkitUserSelect = value;

  const dialog = document.getElementById('toolbar-option-info-dialog');
  dialog.style.userSelect = value;
  dialog.style.webkitUserSelect = value;
}

// eslint-disable-next-line no-unused-vars
function init() {
  CANVAS_WIDTH = window.screen.width;
  CANVAS_HEIGHT = window.screen.height;

  let canvasWrapper = document.getElementById("canvasWrapper");

  const backgroundCanvas = document.createElement("canvas");
  backgroundCanvas.id = "background-canvas";
  backgroundCanvas.width = CANVAS_WIDTH;
  backgroundCanvas.height = CANVAS_HEIGHT;
  canvasWrapper.appendChild(backgroundCanvas);

  const fillCanvas = document.createElement("canvas");
  fillCanvas.classList.add("fill-canvas");
  fillCanvas.width = CANVAS_WIDTH;
  fillCanvas.height = CANVAS_HEIGHT;
  canvasWrapper.appendChild(fillCanvas);

  fillPixelGridHistory.unshift(Array.from({length: CANVAS_WIDTH}, () => Array.from({length: CANVAS_HEIGHT})));
  fillImageDataHistory.unshift(fillCanvas.getContext("2d", {willReadFrequently: true}).getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT));
  fillCanvasHistory.unshift(fillCanvas);

  const brushCanvas = document.createElement("canvas");
  brushCanvas.classList.add("brush-canvas");
  brushCanvas.width = CANVAS_WIDTH;
  brushCanvas.height = CANVAS_HEIGHT;
  canvasWrapper.appendChild(brushCanvas);

  brushPixelGridHistory.unshift(Array.from({length: CANVAS_WIDTH}, () => Array.from({length: CANVAS_HEIGHT})));
  brushCanvasHistory.unshift(brushCanvas);

  combinedHistory.unshift("");

  setCssVar('--canvas-width', `${CANVAS_WIDTH}px`);
  setCssVar('--canvas-height', `${CANVAS_HEIGHT}px`);
  setCssVar('--canvas-scale', `${getToolbarData().canvasScale / 100}`);

  // More of a nuisance than helpful, and doesn't even work on mobile
  // window.addEventListener('beforeunload', (event) => {
  //   if (historyIndex < pixelGridHistory.length - 1) {
  //     // Triggers a confirmation dialog
  //     event.preventDefault();
  //   }
  // });

  document.getElementById('shareButton').style.display = navigator.share ? null : 'none';

  const toolTipElements = [...document.querySelectorAll('#toolbar button'),
      ...document.querySelectorAll('#toolbar label:has(input:not([type=range]))')];

  for (const toolTipElement of toolTipElements) {
    toolTipElement.addEventListener('contextmenu', (event) => {
      event.preventDefault();

      const element = event.currentTarget;
      const iconWrapper = element.querySelector('& > span');

      openOptionInfoDialog(iconWrapper.innerText || iconWrapper.innerHTML, element.title, element.dataset.description);
    });

    // iOS Safari doesn't support contextmenu events, so need to implement long-press manually
    let longPressTimeoutId;
    let longPressTouchId;
    const globalTouches = new Map();

    document.addEventListener('touchmove', (event) => {
      for (const touch of event.changedTouches) {
        globalTouches.set(touch.identifier, touch);
      }
    });

    toolTipElement.addEventListener('touchstart', (event) => {
      for (const touch of event.changedTouches) {
        globalTouches.set(touch.identifier, touch);
      }

      const element = event.currentTarget;
      longPressTouchId = event.changedTouches[0].identifier;

      clearTimeout(longPressTimeoutId);
      longPressTimeoutId = setTimeout(() => {
        clearTimeout(longPressTimeoutId);
        longPressTimeoutId = null;
        const touch = globalTouches.get(longPressTouchId);

        if (!document.elementsFromPoint(touch.clientX, touch.clientY).includes(element)) {
          return;
        }

        // Clear any text selection that might have been triggered
        window.getSelection().removeAllRanges();

        // Temporarily disable future text selection
        setUserSelect(false);

        const iconWrapper = element.querySelector('& > span');
        openOptionInfoDialog(iconWrapper.innerText || iconWrapper.innerHTML, element.title, element.dataset.description);
      }, 600);
    });

    toolTipElement.addEventListener('touchend', (event) => {
      for (const touch of event.changedTouches) {
        globalTouches.delete(touch.identifier);
      }

      // If the popup was opened by a long-press, prevent the context menu from triggering
      if (longPressTimeoutId == null && longPressTouchId != null) {
        for (const touch of event.changedTouches) {
          if (touch.identifier === longPressTouchId) {
            // Clear any text selection that might have been triggered
            window.getSelection().removeAllRanges();

            event.preventDefault();
            break;
          }
        }
      }

      // Re-enable text selection
      setUserSelect(true);

      clearTimeout(longPressTimeoutId);
      longPressTimeoutId = null;
      longPressTouchId = null;
    }, { passive: false });

    toolTipElement.addEventListener('touchcancel', () => {
      for (const touch of event.changedTouches) {
        globalTouches.delete(touch.identifier);
      }

      // Re-enable text selection
      setUserSelect(true);

      clearTimeout(longPressTimeoutId);
      longPressTimeoutId = null;
      longPressTouchId = null;
    });
  }
}
</script>
</head>

<body onload="init()" onmousemove="onCanvasMouseMove(event)">
  <!-- Toolbar Info Dialog -->
  <dialog id="toolbar-option-info-dialog" aria-label="Option Info">
    <div class="modal-backdrop" onclick="if (event.target === this) { closeOptionInfoDialog() }">
      <div class="modal-foreground">
        <button autofocus class="close-button" aria-label="Close dialog" onclick="closeOptionInfoDialog()">
          <span aria-hidden="true">&#65038;</span>
        </button>

        <div class="modal-content"></div>
      </div>
    </div>
  </dialog>

  <main>
    <form id="toolbar" aria-label="Toolbar">
      <p id="toolbar-info" class="collapsible">Right-click or long-press an option for info</p>

      <div class="outer-menu">
        <button type="button" aria-label="View Canvas" title="View Canvas" onclick="viewCanvas()"
            data-description="Hides everything but the canvas until the next interaction.">
          <span aria-hidden="true"></span>
        </button>

        <div class="menu">
          <div role="radiogroup" aria-label="Tools">
            <label aria-label="Brush" title="Brush"
                data-description="Select this tool to draw black outlines.  Fill and erasure blooms stop at outlines.  Erasing outlines themselves leaves the corresponding fill area blank but leaves the surrounding area untouched.  You can then fill the erased outline area as a way to effectively get colored outlines.">
              <span aria-hidden="true"></span>
              <input type="radio" name="tool" value="brush" aria-label="Brush" checked />
            </label>

            <label aria-label="Fill" title="Fill"
                data-description="Select this tool to slowly fill a blank area with a configurable bloom of color, stopping at outlines.  Works with a single click/tap or by dragging.  Set all variances to 0 for a traditional solid fill.  Click/tap a filled area or the background outside the canvas to stop any fill blooms prematurely.">
              <span aria-hidden="true"></span>
              <input type="radio" name="tool" value="fill" aria-label="Fill" />
            </label>

            <label aria-label="Erase" title="Erase"
                data-description="Select this tool to slowly erase filled areas or outlines, whichever is targeted first.  Works with a single click/tap or by dragging.  Click/tap a blank area or the background outside the canvas to stop any erasure blooms prematurely.">
              <span aria-hidden="true"></span>
              <input type="radio" name="tool" value="erase" aria-label="Erase" />
            </label>
          </div>

          <div class="collapsible">
            <label id="show-guidelines" aria-label="Show Guidelines" title="Show Guidelines"
                data-description="When toggled on, shows lines to help target the canvas center.">
              <span aria-hidden="true"></span>
              <input type="checkbox" name="show-guidelines" aria-label="Show Guidelines" />
            </label>

            <button type="button" aria-label="Reset Scale and Position" title="Reset Scale and Position" onclick="resetScaleAndPosition()"
                data-description="Resets the canvas scale and position to their starting values.  In addition to the slider, canvas scale can be adjusted by pinching/spreading on a touchscreen or with the mouse wheel.  Canvas position can be adjusted by dragging with multiple fingers on a touchscreen or while holding the right or middle mouse button.">
              <span aria-hidden="true"></span>
            </button>

            <label>
              Canvas Scale
              <input type="range" id="canvasScale" name="canvasScale" min="25" max="200" value="50" step="5"
                  oninput="onCanvasScaleValueChange(event.currentTarget.value, 'canvasScaleValue')" />
              <span id="canvasScaleValue">50%</span>
            </label>

            <button id="shareButton" type="button" aria-label="Share Canvas Image" title="Share Canvas Image" onclick="share()"
                data-description="Allows you to share your canvas image with others.">
              <span aria-hidden="true"></span>
            </button>

            <button id="downloadButton" type="button" aria-label="Download Canvas Image" title="Download Canvas Image" onclick="download()"
                data-description="Downloads your canvas image.  It's sized to your device's screen, so it can be used as a wallpaper.">
              <span aria-hidden="true"></span>
            </button>
          </div>

          <div>
            <button type="button" aria-label="Reset Canvas" title="Reset Canvas" onclick="resetCanvas()"
                data-description="Instantly erases all filled areas and outlines.  Can be undone the same as other actions.">
              <span aria-hidden="true"></span>
            </button>

            <button id="undoButton" type="button" aria-label="Undo" title="Undo" onclick="undo()" disabled
                data-description="Undoes the previous fill or outline change.  Only the last 10 changes are tracked.">
              <span aria-hidden="true"></span>
            </button>

            <button id="redoButton" type="button" aria-label="Redo" title="Redo" onclick="redo()" disabled
                data-description="Redoes the most recently undone fill or outline change.">
              <span aria-hidden="true"></span>
            </button>
          </div>
        </div>

        <label id="toggle-collapse" aria-label="Toggle Toolbar Collapse" title="Toggle Toolbar Collapse"
            data-description="Toggles between a collapsed, minimalist toolbar and the full toolbar.">
          <span aria-hidden="true">
            <span></span>
            <span></span>
          </span>
          <input type="checkbox" name="toggle-collapse" />
        </label>
      </div>

      <div class="brush-menu submenu collapsible" role="group" aria-label="Brush Submenu">
        <div>
          <label>
            Brush Size
            <input type="range" name="brushSize" min="5" max="100" value="15" step="1"
                oninput="onRangeValueChange(event, 'brushSizeValue', false)" />
            <span id="brushSizeValue">15</span>
          </label>

          <label>
            Smoothing
            <input type="range" name="smoothing" min="0" max="1" value="0.25" step="0.05"
                oninput="onRangeValueChange(event, 'smoothingValue')" />
            <span id="smoothingValue">25%</span>
          </label>
        </div>

        <div>
          <button type="button" aria-label="Generate Ellipses Pattern" title="Generate Ellipses Pattern" onclick="generateEllipsesPattern()"
              data-description="Generates a random smattering of ellipses outlines.  Can be stacked or undone/reattempted as desired.">
            <span aria-hidden="true"></span>
          </button>

          <button type="button" aria-label="Generate Rectangles Pattern" title="Generate Rectangles Pattern" onclick="generateRectanglesPattern()"
              data-description="Generates a random smattering of orthogonal outlines.  Can be stacked or undone/reattempted as desired.">
            <span aria-hidden="true"></span>
          </button>

          <button type="button" aria-label="Generate Diamonds Pattern" title="Generate Diamonds Pattern" onclick="generateDiamondsPattern()"
              data-description="Generates a random smattering of diagonal outlines.  Can be stacked or undone/reattempted as desired.">
            <span aria-hidden="true"></span>
          </button>
        </div>

        <div>
          <button type="button" aria-label="Add Heart Rose Template" title="Add Heart Rose Template" onclick="loadTemplate('heart-rose.png')"
              data-description="Adds a heart rose template outline, centered on the canvas.">
            <span aria-hidden="true"></span>
          </button>

          <button type="button" aria-label="Add Palm Tree Template" title="Add Palm Tree Template" onclick="loadTemplate('palm-tree.png')"
              data-description="Adds a palm tree template outline, centered on the canvas.">
            <span aria-hidden="true"></span>
          </button>
        </div>
      </div>

      <div class="fill-menu submenu collapsible" role="group" aria-label="Fill Submenu">
        <div>
          <label id="limitless-fill" aria-label="Limitless Fill" title="Limitless Fill"
              data-description="Toggle this off to restrict each fill bloom to a configured size and also allow for some targeting leeway to easily fill in stray blank spots.">
            <span aria-hidden="true"></span>
            <input type="checkbox" name="limitless-fill" aria-label="Limitless Fill" checked onchange="stopGrowth(); document.getElementById('fill-size').disabled = event.currentTarget.checked;" />
          </label>

          <label>
            Fill Size
            <input id="fill-size" type="range" name="fillSize" min="50" max="500" value="200" step="10"
                oninput="stopGrowth(); onRangeValueChange(event, 'fillSizeValue', false);" disabled />
            <span id="fillSizeValue">200</span>
          </label>
        </div>

        <label aria-label="Color for Fill" title="Color for Fill"
            data-description="Selects the starting color for fill blooms.">
          <span style="visibility: hidden;"></span>
          <input type="color" name="fillColor" oninput="onFillColorChange(event)" />
        </label>

        <div>
          <label>
            Hue Variance
            <input type="range" name="hueMutation" min="0" max="1" step="0.01" value="0.5"
                oninput="onRangeValueChange(event, 'hueMutationValue')" />
            <span id="hueMutationValue">50%</span>
          </label>

          <label>
            Saturation Variance
            <input type="range" name="saturationMutation" min="0" max="1" step="0.01" value="0.1"
                oninput="onRangeValueChange(event, 'saturationMutationValue')" />
            <span id="saturationMutationValue">10%</span>
          </label>

          <label>
            Lightness Variance
            <input type="range" name="valueMutation" min="0" max="1" step="0.01" value="0.5"
                oninput="onRangeValueChange(event, 'lightnessMutationValue')" />
            <span id="lightnessMutationValue">50%</span>
          </label>
        </div>
      </div>

      <div class="erase-menu submenu collapsible" role="group" aria-label="Erase Submenu">
        <div>
          <label id="limitless-erase" aria-label="Limitless Erase" title="Limitless Erase"
              data-description="Toggle this off to restrict each erasure bloom to a configured size and also allow for some targeting leeway to easily erase stray filled spots.">
            <span aria-hidden="true"></span>
            <input type="checkbox" name="limitless-erase" aria-label="Limitless Erase" checked onchange="stopGrowth(); document.getElementById('erase-size').disabled = event.currentTarget.checked;" />
          </label>

          <label>
            Erase Size
            <input id="erase-size" type="range" name="eraseSize" min="50" max="500" value="200" step="10"
                oninput="stopGrowth(); onRangeValueChange(event, 'eraseSizeValue', false);" disabled />
            <span id="eraseSizeValue">200</span>
          </label>
        </div>
      </div>
    </form>

    <div
      id="contentWrapper"
      onmousedown="onCanvasMouseDown(event)"
      ontouchstart="onCanvasTouchStart(event)"
      onmouseup="onCanvasMouseUp(event)"
      ontouchend="onCanvasTouchEnd(event)"
      ontouchcancel="onCanvasTouchEnd(event)"
      onmouseenter="onCanvasMouseEnter(event)"
      onmouseleave="onCanvasMouseLeave(event)"
      ontouchmove="onCanvasTouchMove(event)"
      onwheel="onCanvasScroll(event)"
      oncontextmenu="onContextMenu(event)"
    >
      <div class="guide vertical center"></div>
      <div class="guide horizontal center"></div>
      <div class="guide vertical cursor"></div>
      <div class="guide horizontal cursor"></div>

      <div id="canvasWrapper"></div>
    </div>

    <!-- Portfolio Link -->
    <a id="portfolio-link" class="collapsible" href="https://alec-mitnik.github.io/" target="_blank" rel="author"
        aria-label="Check out my other projects">
      <img src="./images/PXL_Avatar_1B.jpg" alt="">
    </a>
  </main>
</body>
</html>
